<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Reading Experiment</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Papers data -->
    <script src="papers-data.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, doc, getDoc, setDoc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyDPd-Fz-PdUwc9uvXAg_xEVR5FyPWCg_zA",
            authDomain: "paper-understanding.firebaseapp.com",
            projectId: "paper-understanding",
            storageBucket: "paper-understanding.firebasestorage.app",
            messagingSenderId: "702665730649",
            appId: "1:702665730649:web:9858bde469085a240fdf48"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Make Firebase available globally
        window.firebaseDb = db;
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseDoc = doc;
        window.firebaseGetDoc = getDoc;
        window.firebaseSetDoc = setDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseServerTimestamp = serverTimestamp;
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Icons
        const SendIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const ClockIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        );

        const CheckIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
        );

        // Timer Component
        function Timer({ seconds, onComplete, isActive, phase }) {
            const [timeLeft, setTimeLeft] = useState(seconds);

            useEffect(() => {
                // Reset timer when phase changes
                setTimeLeft(seconds);
            }, [phase, seconds]);

            useEffect(() => {
                if (!isActive) return;
                
                const interval = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            clearInterval(interval);
                            if (onComplete) onComplete();
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isActive, onComplete]);

            const minutes = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            const isLowTime = timeLeft < 300; // 5Î∂Ñ ÎØ∏Îßå

            return (
                <div className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-mono text-lg ${
                    isLowTime ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700'
                }`}>
                    <ClockIcon />
                    <span>{String(minutes).padStart(2, '0')}:{String(secs).padStart(2, '0')}</span>
                </div>
            );
        }

        // Main Application Component
        function PDFReadingExperiment() {
            // Experiment mode state
            const [mode, setMode] = useState('experiment'); // 'experiment' or 'test'
            const [sessionNumber, setSessionNumber] = useState(1); // 1 or 2 for experiment mode
            const [sessionOrder, setSessionOrder] = useState([]); // Loaded from Firebase

            // Experiment flow state
            const [phase, setPhase] = useState('setup'); // setup, reading-guide, reading, quiz-guide, quiz, review-guide, review, session-complete, all-complete
            const [participantId, setParticipantId] = useState('');
            const [condition, setCondition] = useState('without_llm');
            const [currentPaper, setCurrentPaper] = useState('');
            const [sessionId] = useState(`session_${Date.now()}`);
            const [showFinishPopup, setShowFinishPopup] = useState(false); // For finish confirmation popups
            const [bankAccount, setBankAccount] = useState(''); // For compensation

            // Reading phase state
            const [scrollPosition, setScrollPosition] = useState(0);
            const [currentSection, setCurrentSection] = useState('Introduction');
            const [selectedText, setSelectedText] = useState('');
            const [readingActive, setReadingActive] = useState(false);
            const [paperContent, setPaperContent] = useState('');
            
            // Focus state (for with_llm condition) - cursor-based tracking
            const [activeFocus, setActiveFocus] = useState('reading'); // 'reading' or 'chat'
            const [focusTimes, setFocusTimes] = useState({ reading: 0, chat: 0 });
            const focusStartTimeRef = useRef(Date.now());
            const savedScrollPosition = useRef(0); // Ïä§ÌÅ¨Î°§ ÏúÑÏπò Ï†ÄÏû•Ïö©

            // Quiz phase state
            const [quizActive, setQuizActive] = useState(false);
            const [quizAnswers, setQuizAnswers] = useState({});

            // Review phase state
            const [reviewActive, setReviewActive] = useState(false);
            const [reviewData, setReviewData] = useState({
                rating: 0,
                strengths: '',
                weaknesses: '',
                suggestions: ''
            });

            // Chat state (for LLM condition) - enhanced
            const [messages, setMessages] = useState([]);
            const [inputMessage, setInputMessage] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [showPlusMenu, setShowPlusMenu] = useState(false);
            const [chatHistory, setChatHistory] = useState([]); // Full Q&A log
            const [uploadedFiles, setUploadedFiles] = useState([]); // Track uploaded files
            const chatMessagesEndRef = useRef(null); // For auto-scroll to bottom
            const textareaRef = useRef(null); // For textarea height control

            // Timer tracking
            const phaseStartTime = useRef(Date.now());
            const phaseTimers = useRef({
                reading: 0,
                quiz: 0,
                review: 0
            });

            // Logging state
            const [events, setEvents] = useState([]);
            const lastEventTime = useRef(Date.now());
            const unsavedEventsCount = useRef(0); // Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùÄ Ïù¥Î≤§Ìä∏ Ïπ¥Ïö¥ÌÑ∞
            const lastSaveTimestamp = useRef(Date.now()); // ÎßàÏßÄÎßâ Ï†ÄÏû• ÏãúÍ∞Ñ
            const eventIdCounter = useRef(0); // Í≥†Ïú† ID ÏÉùÏÑ±Ïö© Ïπ¥Ïö¥ÌÑ∞
            const isSaving = useRef(false); // Ï†ÄÏû• Ï§ë ÌîåÎûòÍ∑∏
            const pdfContainerRef = useRef(null);
            const scrollTimeoutRef = useRef(null);
            const lastActivityTimeRef = useRef(Date.now()); // ÎßàÏßÄÎßâ ÌôúÎèô ÏãúÍ∞Ñ (scroll stop ÎòêÎäî tab return)
            const scrollStartTimeRef = useRef(null); // Track when scroll starts
            const isScrollingRef = useRef(false); // Track if currently scrolling
            const sectionBeforeScrollRef = useRef('Introduction'); // Ïä§ÌÅ¨Î°§ ÏãúÏûë Ï†Ñ ÏÑπÏÖò
            
            // LLM typing tracking
            const isTypingRef = useRef(false); // ÌòÑÏû¨ ÌÉÄÏù¥Ìïë Ï§ëÏù∏ÏßÄ
            const typingTimeoutRef = useRef(null); // ÌÉÄÏù¥Ìïë Î©àÏ∂§ Í∞êÏßÄÏö©
            const lastTypingActivityRef = useRef(Date.now()); // ÎßàÏßÄÎßâ ÌÉÄÏù¥Ìïë ÌôúÎèô ÏãúÍ∞Ñ

            // Papers - use from shared data file
            const papers = AVAILABLE_PAPERS;

            // Quiz questions state - will be loaded dynamically based on current paper
            const [quizQuestions, setQuizQuestions] = useState([
                {
                    id: 1,
                    question: "What was the primary methodology used in this study?",
                    options: ["Qualitative analysis", "Quantitative experiments", "Mixed methods", "Literature review"],
                    correctAnswer: "Mixed methods",
                    section: "Methods"
                },
                {
                    id: 2,
                    question: "What was the main finding of the research?",
                    options: ["Option A", "Option B", "Option C", "Option D"],
                    correctAnswer: "Option A",
                    section: "Results"
                },
            ]);

            // Section boundaries
            // Section boundaries - will be loaded dynamically per paper
            const [sectionBoundaries, setSectionBoundaries] = useState({
                'Abstract': { start: 0, end: 200 },
                'Introduction': { start: 200, end: 800 },
                'Methods': { start: 800, end: 1400 },
                'Results': { start: 1400, end: 2200 },
                'Discussion': { start: 2200, end: 2800 },
                'Conclusion': { start: 2800, end: 3200 },
            });

            // Initialize from URL parameters
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const urlPid = urlParams.get('participantId');
                const urlCondition = urlParams.get('condition');
                const urlPaper = urlParams.get('paper');
                const urlMode = urlParams.get('mode') || 'experiment';
                const urlSessionNum = urlParams.get('sessionNumber') || '1';

                if (urlPid) setParticipantId(urlPid);
                if (urlCondition) setCondition(urlCondition);
                if (urlPaper) setCurrentPaper(urlPaper);
                setMode(urlMode);
                setSessionNumber(parseInt(urlSessionNum));

                // If experiment mode, load session order from Firebase
                if (urlMode === 'experiment' && urlPid) {
                    const loadSessionOrder = async () => {
                        try {
                            const userDocRef = window.firebaseDoc(window.firebaseDb, 'users', urlPid);
                            const userDocSnap = await window.firebaseGetDoc(userDocRef);

                            if (userDocSnap.exists()) {
                                const data = userDocSnap.data();
                                if (data.sessionOrder) {
                                    setSessionOrder(data.sessionOrder);
                                    console.log('‚úÖ Loaded session order:', data.sessionOrder);
                                }
                            }
                        } catch (error) {
                            console.error('‚ùå Failed to load session order:', error);
                        }
                    };
                    loadSessionOrder();
                }

                // Auto-start if all parameters are provided
                if (urlPid && urlCondition && urlPaper) {
                    console.log(`üöÄ Auto-starting: mode=${urlMode}, session=${urlSessionNum}, condition=${urlCondition}`);
                    // Wait a bit for Firebase to load session order if needed
                    setTimeout(() => {
                        // Trigger experiment start directly by setting phase
                        const paper = papers.find(p => p.id === urlPaper);
                        if (paper && paper.url) {
                            fetch(paper.url)
                                .then(response => response.text())
                                .then(html => {
                                    const parser = new DOMParser();
                                    const doc = parser.parseFromString(html, 'text/html');
                                    const proseDiv = doc.querySelector('.prose');

                                    if (proseDiv) {
                                        console.log('üîç Extracted HTML contains h3 tags:', proseDiv.innerHTML.includes('<h3'));
                                        console.log('üîç Number of h3 tags:', (proseDiv.innerHTML.match(/<h3/g) || []).length);
                                        setPaperContent(proseDiv.innerHTML);

                                        // Load quiz questions for this paper
                                        fetch(`questions_data/${urlPaper}.json`)
                                            .then(response => {
                                                if (response.ok) {
                                                    return response.json();
                                                } else {
                                                    console.warn(`‚ö†Ô∏è No questions found for ${urlPaper}, using default questions`);
                                                    return null;
                                                }
                                            })
                                            .then(data => {
                                                if (data && data.questions) {
                                                    setQuizQuestions(data.questions);
                                                    console.log(`‚úÖ Loaded ${data.questions.length} questions for ${urlPaper}`);
                                                }
                                            })
                                            .catch(error => {
                                                console.error('Error loading questions:', error);
                                            });

                                        // Calculate section boundaries from DOM
                                        setTimeout(() => {
                                            const sections = document.querySelectorAll('[data-section]');
                                            const container = document.getElementById('paper-content') || document.querySelector('.prose');

                                            if (sections.length > 0 && container) {
                                                const newBoundaries = {};

                                                sections.forEach((section, index) => {
                                                    const sectionName = section.getAttribute('data-section');
                                                    const sectionTop = section.offsetTop;

                                                    let sectionEnd;
                                                    if (index < sections.length - 1) {
                                                        sectionEnd = sections[index + 1].offsetTop;
                                                    } else {
                                                        sectionEnd = container.scrollHeight;
                                                    }

                                                    newBoundaries[sectionName] = {
                                                        start: sectionTop,
                                                        end: sectionEnd
                                                    };
                                                });

                                                setSectionBoundaries(newBoundaries);
                                                console.log('üìä Section Boundaries loaded:', newBoundaries);

                                                // Set initial section
                                                const firstSection = Object.keys(newBoundaries)[0];
                                                if (firstSection) {
                                                    setCurrentSection(firstSection);
                                                }
                                            } else {
                                                console.warn('‚ö†Ô∏è No sections found in paper');
                                            }
                                        }, 500); // Wait for DOM to render

                                    } else {
                                        console.error('Could not find .prose element in paper HTML');
                                        setPaperContent('<p>Error: Could not load paper content</p>');
                                    }

                                    setPhase('reading-guide');
                                    logEvent('reading_guide_shown');
                                })
                                .catch(error => {
                                    console.error('Error loading paper:', error);
                                    alert('Failed to load paper. Please try again.');
                                });
                        } else {
                            console.error('Paper not found:', urlPaper);
                        }
                    }, 500); // Wait for Firebase data to load
                }
            }, []);

            // Prevent back navigation during experiment
            useEffect(() => {
                // Push a dummy state to prevent initial back
                window.history.pushState(null, '', window.location.href);

                const handlePopState = (e) => {
                    // Restore the current state
                    window.history.pushState(null, '', window.location.href);

                    // Show warning popup
                    const confirmBack = window.confirm(
                        'Îí§Î°ú Í∞ÄÏãúÍ≤†ÏäµÎãàÍπå?\n\nÎí§Î°ú Í∞ÄÏãúÎ©¥ ÌòÑÏû¨ÍπåÏßÄÏùò ÏßÑÌñâ ÏÉÅÌô©Ïù¥ Ï†ÄÏû•ÎêòÏßÄ ÏïäÏïÑ Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú ÏãúÏûëÌï¥Ïïº Ìï† Ïàò ÏûàÏäµÎãàÎã§.'
                    );

                    if (confirmBack) {
                        // If user confirms, allow them to go back
                        window.history.back();
                    }
                };

                window.addEventListener('popstate', handlePopState);

                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, []);

            // Auto-save on browser close/refresh
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    // Save unsaved events before closing
                    if (phase === 'reading' && unsavedEventsCount.current > 0) {
                        console.log(`üö® Saving ${unsavedEventsCount.current} unsaved events before closing...`);

                        // Synchronous save using sendBeacon (more reliable for beforeunload)
                        const eventsToSave = events.filter(e =>
                            e.phase === 'reading' &&
                            (e.eventType === 'scroll_action' ||
                             e.eventType === 'focus_switch' ||
                             e.eventType === 'tab_switch' ||
                             e.eventType === 'llm_activity' ||
                             e.eventType === 'text_selection')
                        );

                        if (eventsToSave.length > 0) {
                            // Try async save first
                            saveEventsToFirebase(eventsToSave, false).catch(err => {
                                console.error('Failed to save on unload:', err);
                            });
                        }
                    }

                    // Optional: Show confirmation dialog
                    if (phase === 'reading' || phase === 'quiz' || phase === 'review') {
                        e.preventDefault();
                        e.returnValue = ''; // Chrome requires returnValue to be set
                        return '';
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);

                return () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                };
            }, [phase, events, unsavedEventsCount.current]);

            // Auto-scroll chat to bottom when messages change
            useEffect(() => {
                if (chatMessagesEndRef.current) {
                    chatMessagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages, isLoading]);

            // Create experiment document when entering reading-guide phase
            React.useEffect(() => {
                const createExperimentDoc = async () => {
                    if (phase === 'reading-guide' && participantId && sessionId && currentPaper) {
                        try {
                            if (window.firebaseDb) {
                                const experimentRef = window.firebaseDoc(
                                    window.firebaseDb,
                                    `users/${participantId}/experiments/${sessionId}`
                                );

                                await window.firebaseSetDoc(experimentRef, {
                                    participantId: participantId,
                                    sessionId: sessionId,
                                    condition: condition,
                                    paper: currentPaper,
                                    sessionNumber: sessionNumber,
                                    startedAt: window.firebaseServerTimestamp(),
                                    status: 'in_progress',
                                    createdAt: Date.now()
                                });

                                console.log('‚úÖ Experiment document created:', `users/${participantId}/experiments/${sessionId}`);
                            }
                        } catch (error) {
                            console.error('‚ùå Failed to create experiment document:', error);
                        }
                    }
                };
                createExperimentDoc();
            }, [phase]);

            // Calculate section boundaries when entering reading phase
            React.useEffect(() => {
                if (phase === 'reading' && paperContent) {
                    // Wait for DOM to render
                    setTimeout(() => {
                        const sections = document.querySelectorAll('[data-section]');
                        const container = document.getElementById('paper-content') || document.querySelector('.prose');

                        if (sections.length > 0 && container) {
                            const newBoundaries = {};

                            sections.forEach((section, index) => {
                                const sectionName = section.getAttribute('data-section');
                                const sectionTop = section.offsetTop;

                                let sectionEnd;
                                if (index < sections.length - 1) {
                                    sectionEnd = sections[index + 1].offsetTop;
                                } else {
                                    sectionEnd = container.scrollHeight;
                                }

                                newBoundaries[sectionName] = {
                                    start: sectionTop,
                                    end: sectionEnd
                                };
                            });

                            setSectionBoundaries(newBoundaries);
                            console.log('üìä Section Boundaries calculated on reading phase:', newBoundaries);

                            // Set initial section
                            const firstSection = Object.keys(newBoundaries)[0];
                            if (firstSection) {
                                setCurrentSection(firstSection);
                            }
                        } else {
                            console.warn('‚ö†Ô∏è No sections found in paper (reading phase)');
                        }
                    }, 500); // Wait for React to render
                }
            }, [phase, paperContent]);

            // Auto-save events to Firebase
            const saveEventsToFirebase = async (eventsBatch, isPartialSave = true) => {
                // Ïù¥ÎØ∏ Ï†ÄÏû• Ï§ëÏù¥Î©¥ Í±¥ÎÑàÎõ∞Í∏∞ (race condition Î∞©ÏßÄ)
                if (isSaving.current) {
                    console.log('‚è≥ Save already in progress, skipping...');
                    return false;
                }

                isSaving.current = true;

                try {
                    if (!window.firebaseDb || !participantId || !sessionId) {
                        console.warn('‚ö†Ô∏è Firebase not ready for auto-save');
                        isSaving.current = false;
                        return false;
                    }

                    const experimentRef = window.firebaseDoc(
                        window.firebaseDb,
                        `users/${participantId}/experiments/${sessionId}`
                    );

                    // Reading phaseÏùò Í¥ÄÎ†® Ïù¥Î≤§Ìä∏Îßå ÌïÑÌÑ∞ÎßÅ
                    const readingEvents = eventsBatch.filter(e =>
                        e.phase === 'reading' &&
                        (e.eventType === 'scroll_action' ||
                         e.eventType === 'focus_switch' ||
                         e.eventType === 'tab_switch' ||
                         e.eventType === 'llm_activity' ||
                         e.eventType === 'text_selection')
                    );

                    if (readingEvents.length === 0) {
                        isSaving.current = false;
                        return true;
                    }

                    // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏùΩÏñ¥Ïò§Í∏∞
                    const docSnap = await window.firebaseGetDoc(experimentRef);
                    const existingEvents = docSnap.exists() && docSnap.data().reading?.events
                        ? docSnap.data().reading.events
                        : [];

                    // Ï§ëÎ≥µ Î∞©ÏßÄ: eventId (Í≥†Ïú†) ÎòêÎäî timestamp+eventType Ï°∞Ìï©ÏúºÎ°ú Ï≤¥ÌÅ¨
                    const existingKeys = new Set(
                        existingEvents.map(e => e.eventId || `${e.timestamp}_${e.eventType}`)
                    );
                    const newEventsOnly = readingEvents.filter(e => {
                        const key = e.eventId || `${e.timestamp}_${e.eventType}`;
                        return !existingKeys.has(key);
                    });

                    if (newEventsOnly.length === 0) {
                        console.log('‚ÑπÔ∏è No new events to save (all already saved)');
                        unsavedEventsCount.current = 0;
                        isSaving.current = false;
                        return true;
                    }

                    // Î≥ëÌï©Îêú Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥ (ÏãúÍ∞ÑÏàú Ï†ïÎ†¨)
                    const mergedEvents = [...existingEvents, ...newEventsOnly].sort((a, b) => a.timestamp - b.timestamp);

                    const updateData = {
                        'reading.events': mergedEvents,
                        'reading.lastAutoSave': window.firebaseServerTimestamp(),
                        'reading.totalEvents': mergedEvents.length
                    };

                    await window.firebaseUpdateDoc(experimentRef, updateData);

                    if (isPartialSave) {
                        console.log(`üíæ Auto-saved ${newEventsOnly.length} new events to Firebase (total: ${mergedEvents.length})`);
                    }

                    unsavedEventsCount.current = 0;
                    lastSaveTimestamp.current = Date.now();
                    isSaving.current = false;
                    return true;
                } catch (error) {
                    console.error('‚ùå Auto-save failed:', error);
                    isSaving.current = false;
                    return false;
                }
            };

            // Log event
            const logEvent = async (eventType, additionalData = {}) => {
                const now = Date.now();
                const timeSinceLast = now - lastEventTime.current;

                // Í≥†Ïú† ID ÏÉùÏÑ± (ÏÑ∏ÏÖòID + Ïπ¥Ïö¥ÌÑ∞)
                eventIdCounter.current++;
                const eventId = `${sessionId}_${eventIdCounter.current}`;

                const event = {
                    eventId,  // Í≥†Ïú† ID Ï∂îÍ∞Ä
                    timestamp: now,
                    eventType,
                    phase,
                    timeSinceLast,
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    ...additionalData
                };

                setEvents(prev => {
                    const newEvents = [...prev, event];

                    // Auto-save Ìä∏Î¶¨Í±∞ (20Í∞ú Ïù¥Î≤§Ìä∏ÎßàÎã§)
                    if (phase === 'reading') {
                        unsavedEventsCount.current++;

                        if (unsavedEventsCount.current >= 20) {
                            console.log(`üì¶ Triggering auto-save (${unsavedEventsCount.current} unsaved events)`);
                            // async Ìï®ÏàòÎ•º await ÏóÜÏù¥ Ìò∏Ï∂ú (ÏùòÎèÑÏ†Å - Î∞±Í∑∏ÎùºÏö¥Îìú Ï†ÄÏû•)
                            saveEventsToFirebase(newEvents, true).catch(err => {
                                console.error('Auto-save error:', err);
                            });
                        }
                    }

                    return newEvents;
                });
                lastEventTime.current = now;

                // Local storage backup
                const storedEvents = JSON.parse(localStorage.getItem('experimentEvents') || '[]');
                storedEvents.push(event);
                localStorage.setItem('experimentEvents', JSON.stringify(storedEvents));

                // Firebase: LLM Í¥ÄÎ†® Ïù¥Î≤§Ìä∏Îßå Ïã§ÏãúÍ∞Ñ Ï†ÄÏû•
                if (eventType === 'llm_question_asked' || eventType === 'llm_answer_received') {
                    try {
                        if (window.firebaseDb && participantId && sessionId) {
                            const experimentRef = window.firebaseDoc(
                                window.firebaseDb,
                                `users/${participantId}/experiments/${sessionId}`
                            );

                            // LLM Î©îÏãúÏßÄÎäî Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ï∂îÍ∞Ä
                            const currentMessages = [...chatHistory];
                            if (eventType === 'llm_answer_received' && additionalData.question) {
                                currentMessages.push({
                                    question: additionalData.question,
                                    answer: additionalData.answer,
                                    responseTime: additionalData.responseTime,
                                    questionTime: now - additionalData.responseTime,
                                    answerTime: now
                                });
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to save LLM event:', error);
                    }
                }
            };

            // Get current section based on viewport center
            const getCurrentSection = (scrollY, viewportHeight) => {
                // Use viewport center as reference point
                const viewportCenter = scrollY + (viewportHeight / 2);
                
                let closestSection = null;
                let closestDistance = Infinity;
                
                // Find which section the viewport center is in
                for (const [section, bounds] of Object.entries(sectionBoundaries)) {
                    // Check if viewport center is within this section
                    if (viewportCenter >= bounds.start && viewportCenter < bounds.end) {
                        return section;
                    }
                    
                    // If no exact match, find closest section (prevents "Unknown")
                    const distanceToStart = Math.abs(viewportCenter - bounds.start);
                    const distanceToEnd = Math.abs(viewportCenter - bounds.end);
                    const minDistance = Math.min(distanceToStart, distanceToEnd);
                    
                    if (minDistance < closestDistance) {
                        closestDistance = minDistance;
                        closestSection = section;
                    }
                }
                
                // Return closest section if no exact match (prevents "Unknown")
                return closestSection || Object.keys(sectionBoundaries)[0] || 'Unknown';
            };

            // Tab switching with time tracking
            const switchFocus = (newFocus) => {
                if (newFocus === activeFocus) return;

                const now = Date.now();

                // === Chat Ìè¨Ïª§Ïä§ÏóêÏÑú ÎÇòÍ∞à Îïå: ÎßàÏßÄÎßâ ÌÉÄÏù¥Ìïë Íµ¨Í∞Ñ Ï†ÄÏû• ===
                if (activeFocus === 'chat') {
                    const activityDuration = now - lastTypingActivityRef.current;
                    const classification = isTypingRef.current ? 'typing' : 'none-typing';

                    // Clear typing timeout
                    if (typingTimeoutRef.current) {
                        clearTimeout(typingTimeoutRef.current);
                        typingTimeoutRef.current = null;
                    }

                    logEvent('llm_activity', {
                        classification: classification,
                        duration: activityDuration,
                        isFocusSwitch: true
                    });

                    console.log(`‚å®Ô∏è  [${classification.toUpperCase()}] duration: ${activityDuration}ms before leaving Chat`);

                    // Reset typing state
                    isTypingRef.current = false;
                }

                // ChatÏúºÎ°ú Ï†ÑÌôò: reading ÌÉÄÏù¥Î®∏ Ï§ëÎã® Î∞è ÌòÑÏû¨ Íµ¨Í∞Ñ Ï†ÄÏû•
                if (newFocus === 'chat' && activeFocus === 'reading') {
                    const pauseDuration = now - lastActivityTimeRef.current;

                    let classification;
                    if (pauseDuration > 5000) {
                        classification = 'reading';
                    } else if (pauseDuration > 2000) {
                        classification = 'scanning';
                    } else {
                        classification = 'scrolling';
                    }

                    logEvent('scroll_action', {
                        scrollY: pdfContainerRef.current?.scrollTop || 0,
                        sectionBeforeScroll: currentSection,
                        sectionAfterScroll: currentSection,
                        classification: classification,
                        pauseDuration: pauseDuration,
                        scrollDuration: 0,
                        isFocusSwitch: true,
                        timestamp: now
                    });

                    console.log(`üîÑ [FOCUS ‚Üí CHAT] Saved ${classification}: ${pauseDuration}ms at "${currentSection}"`);

                    // ChatÏúºÎ°ú Îì§Ïñ¥Í∞à Îïå ÌÉÄÏù¥Ìïë ÌÉÄÏù¥Î®∏ Ï¥àÍ∏∞Ìôî
                    lastTypingActivityRef.current = now;
                    isTypingRef.current = false;
                }

                // ReadingÏúºÎ°ú Î≥µÍ∑Ä: ÌÉÄÏù¥Î®∏ Ïû¨ÏãúÏûë
                if (newFocus === 'reading' && activeFocus === 'chat') {
                    lastActivityTimeRef.current = now;
                    console.log(`üîÑ [FOCUS ‚Üí READING] Timer restarted`);
                }

                // Record time spent on current focus
                const elapsed = Date.now() - focusStartTimeRef.current;
                setFocusTimes(prev => ({
                    ...prev,
                    [activeFocus]: prev[activeFocus] + elapsed
                }));

                // Log focus switch with LLM classification
                const switchEventData = {
                    from: activeFocus,
                    to: newFocus,
                    timeOnPreviousFocus: elapsed
                };

                // ChatÏóêÏÑú ÎÇòÍ∞ÄÎäî Í≤ΩÏö∞ ‚Üí LLM durationÏúºÎ°ú Î∂ÑÎ•ò
                if (activeFocus === 'chat') {
                    switchEventData.classification = 'llm';
                    switchEventData.llmDuration = elapsed;
                    console.log(`ü§ñ [LLM] duration: ${elapsed}ms`);
                }

                logEvent('focus_switch', switchEventData);

                // Switch to new focus
                setActiveFocus(newFocus);
                focusStartTimeRef.current = Date.now();
            };
            
            // Handle typing in Chat
            const handleTyping = () => {
                if (activeFocus !== 'chat') return; // Only track in Chat

                const now = Date.now();

                // ÌÉÄÏù¥Ìïë ÏãúÏûë
                if (!isTypingRef.current) {
                    // Ïù¥Ï†Ñ none-typing Íµ¨Í∞Ñ Ï†ÄÏû•
                    const noneTypingDuration = now - lastTypingActivityRef.current;

                    if (noneTypingDuration > 100) { // ÏµúÏÜå 100ms Ïù¥ÏÉÅ
                        logEvent('llm_activity', {
                            classification: 'none-typing',
                            duration: noneTypingDuration
                        });

                        console.log(`‚å®Ô∏è  [NONE-TYPING] duration: ${noneTypingDuration}ms`);
                    }

                    isTypingRef.current = true;
                    lastTypingActivityRef.current = now;
                }

                // Clear existing timeout
                if (typingTimeoutRef.current) {
                    clearTimeout(typingTimeoutRef.current);
                }

                // ÌÉÄÏù¥Ìïë Î©àÏ∂§ Í∞êÏßÄ (2Ï¥à ÎèôÏïà ÌÉÄÏù¥Ìïë ÏóÜÏúºÎ©¥ Î©àÏ∂ò Í≤ÉÏúºÎ°ú Í∞ÑÏ£º)
                typingTimeoutRef.current = setTimeout(() => {
                    const stopTime = Date.now();
                    const typingDuration = stopTime - lastTypingActivityRef.current;

                    logEvent('llm_activity', {
                        classification: 'typing',
                        duration: typingDuration
                    });

                    console.log(`‚å®Ô∏è  [TYPING] duration: ${typingDuration}ms`);

                    // ÌÉÄÏù¥Ìïë Î©àÏ∂§
                    isTypingRef.current = false;
                    lastTypingActivityRef.current = stopTime;
                }, 2000);
            };

            // Handle key press in chat input (shift+enter for newline, enter to send)
            const handleChatKeyDown = (e) => {
                handleTyping(); // Track typing activity

                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent default newline
                    if (inputMessage.trim()) {
                        // Trigger form submit
                        e.target.form.requestSubmit();
                    }
                }
                // If shift+enter, allow default behavior (newline)
            };

            // Auto-resize textarea based on content
            const handleTextareaChange = (e) => {
                setInputMessage(e.target.value);

                // Reset height to auto to get the correct scrollHeight
                e.target.style.height = 'auto';

                // Set height based on scrollHeight, max 11 lines (~264px)
                const lineHeight = 24; // approximate line height
                const maxLines = 11;
                const maxHeight = lineHeight * maxLines;
                const newHeight = Math.min(e.target.scrollHeight, maxHeight);

                e.target.style.height = newHeight + 'px';
            };

            // Handle scroll - track reading behavior
            const handleScroll = (e) => {
                // Don't track scroll if not focused on reading
                if (activeFocus !== 'reading') return;
                
                const scrollY = e.target.scrollTop;
                const viewportHeight = e.target.clientHeight;
                setScrollPosition(scrollY);
                
                const newSection = getCurrentSection(scrollY, viewportHeight);
                if (newSection !== currentSection) {
                    setCurrentSection(newSection);
                    console.log(`üìç Section changed: ${currentSection} ‚Üí ${newSection} (scroll: ${scrollY}px)`);
                }

                const now = Date.now();

                // Ï≤´ Ïä§ÌÅ¨Î°§ ÏãúÏûë
                if (!isScrollingRef.current) {
                    isScrollingRef.current = true;
                    scrollStartTimeRef.current = now;
                    
                    // Ïä§ÌÅ¨Î°§ ÏãúÏûë Ï†Ñ ÏÑπÏÖò Ï†ÄÏû• (Ïó¨Í∏∞ÏÑú ÏùΩÍ∏∞Í∞Ä Î∞úÏÉùÌï®!)
                    sectionBeforeScrollRef.current = currentSection;
                    
                    // Ï≤´ Ïä§ÌÅ¨Î°§Ïù¥Î©¥ lastActivityTimeRef Ï¥àÍ∏∞Ìôî
                    if (lastActivityTimeRef.current === 0) {
                        lastActivityTimeRef.current = now;
                    }
                }

                // Clear existing timeout
                if (scrollTimeoutRef.current) {
                    clearTimeout(scrollTimeoutRef.current);
                }

                // Ïä§ÌÅ¨Î°§ Î©àÏ∂§ Í∞êÏßÄ (200ms ÎèôÏïà Ïä§ÌÅ¨Î°§ ÏóÜÏúºÎ©¥ Î©àÏ∂ò Í≤ÉÏúºÎ°ú Í∞ÑÏ£º)
                scrollTimeoutRef.current = setTimeout(() => {
                    const scrollStopTime = Date.now();
                    
                    // === ÏãúÍ∞Ñ Í≥ÑÏÇ∞ ===
                    // 1. Ïä§ÌÅ¨Î°§ ÏßÄÏÜç ÏãúÍ∞Ñ: Ïä§ÌÅ¨Î°§ ÏãúÏûë ~ Î©àÏ∂§
                    const scrollDuration = scrollStopTime - scrollStartTimeRef.current;
                    
                    // 2. Ïù¥Ï†Ñ Î©àÏ∂§ ~ Ïù¥Î≤à Ïä§ÌÅ¨Î°§ ÏãúÏûë ÏÇ¨Ïù¥Ïùò ÏãúÍ∞Ñ (= ÏùΩÍ∏∞/Î©àÏ∂∞ÏûàÎçò ÏãúÍ∞Ñ)
                    const pauseBeforeScroll = scrollStartTimeRef.current - lastActivityTimeRef.current;
                    
                    // === ÌñâÎèô Î∂ÑÎ•ò (Ïù¥Ï†Ñ Î©àÏ∂§ ÏãúÍ∞Ñ Í∏∞Ï§Ä) ===
                    let classification;
                    if (pauseBeforeScroll > 5000) {
                        classification = 'reading';  // 5Ï¥à Ïù¥ÏÉÅ Î©àÏ∂§ = ÏùΩÍ∏∞
                    } else if (pauseBeforeScroll > 2000) {
                        classification = 'scanning'; // 2-5Ï¥à Î©àÏ∂§ = ÌõëÏñ¥Î≥¥Í∏∞
                    } else {
                        classification = 'scrolling'; // 2Ï¥à ÎØ∏Îßå = Îπ†Î•∏ Ïä§ÌÅ¨Î°§
                    }

                    // === Ïù¥Î≤§Ìä∏ Î°úÍπÖ ===
                    // Ï§ëÏöî: pauseDuration(ÏùΩÍ∏∞)Ïù¥ Î∞úÏÉùÌïú ÏÑπÏÖòÏùÄ Ïä§ÌÅ¨Î°§ ÏãúÏûë Ï†Ñ ÏÑπÏÖò!
                    const sectionWhereReadingOccurred = sectionBeforeScrollRef.current;
                    const sectionAfterScroll = newSection;
                    
                    logEvent('scroll_action', { 
                        scrollY,
                        sectionBeforeScroll: sectionWhereReadingOccurred,  // ÏùΩÍ∏∞Í∞Ä Î∞úÏÉùÌïú ÏÑπÏÖò
                        sectionAfterScroll: sectionAfterScroll,            // Ïä§ÌÅ¨Î°§ ÌõÑ ÎèÑÏ∞©Ìïú ÏÑπÏÖò
                        classification,                                     // reading/scanning/scrolling
                        pauseDuration: pauseBeforeScroll,                   // Ïù¥Ï†Ñ Î©àÏ∂§ ÏãúÍ∞Ñ (ÏùΩÍ∏∞ ÏãúÍ∞Ñ)
                        scrollDuration: scrollDuration,                     // Ïä§ÌÅ¨Î°§ ÏßÄÏÜç ÏãúÍ∞Ñ
                        timestamp: scrollStopTime
                    });

                    console.log(`üîç [${classification.toUpperCase()}] pause: ${pauseBeforeScroll}ms at "${sectionWhereReadingOccurred}", scroll: ${scrollDuration}ms to "${sectionAfterScroll}"`);

                    // === ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ===
                    lastActivityTimeRef.current = scrollStopTime;
                    isScrollingRef.current = false;
                }, 200);
            };

            // Handle text selection
            const handleTextSelection = () => {
                const selection = window.getSelection();
                const text = selection.toString();
                if (text.length > 0) {
                    setSelectedText(text);
                    logEvent('text_selection', { selectedText: text });
                }
            };

            // Send LLM message
            const handleSendMessage = async (e) => {
                e.preventDefault();
                if (!inputMessage.trim() && uploadedFiles.length === 0) return;

                // API ÌÇ§ - GitHub ActionsÏóêÏÑú Ï£ºÏûÖÎê®
                const apiKey = '__OPENAI_API_KEY__'; // ÎπåÎìúÏãú ÍµêÏ≤¥Îê®

                const questionTime = Date.now();

                // Build user message content with files
                let messageContent = inputMessage;
                if (uploadedFiles.length > 0) {
                    const filesList = uploadedFiles.map(f => `üìé ${f.name}`).join('\n');
                    messageContent = `${inputMessage}\n\n${filesList}`;
                }

                const userMessage = {
                    role: 'user',
                    content: messageContent,
                    timestamp: questionTime,
                    files: uploadedFiles.length > 0 ? [...uploadedFiles] : undefined
                };

                setMessages(prev => [...prev, userMessage]);

                // Log with file attachment info
                if (uploadedFiles.length > 0) {
                    logEvent('llm_question_asked_with_files', {
                        question: inputMessage,
                        files: uploadedFiles.map(f => ({ name: f.name, type: f.type, url: f.url })),
                        fileCount: uploadedFiles.length,
                        timestamp: questionTime
                    });
                    console.log(`üí¨ [LLM QUESTION WITH FILES] Question: "${inputMessage}" | Files: ${uploadedFiles.map(f => f.name).join(', ')}`);
                } else {
                    logEvent('llm_question_asked', {
                        question: inputMessage,
                        timestamp: questionTime
                    });
                    console.log(`üí¨ [LLM QUESTION] "${inputMessage}"`);
                }

                setIsLoading(true);
                const queryText = inputMessage;
                const attachedFiles = [...uploadedFiles];
                setInputMessage('');
                setUploadedFiles([]); // Clear attached files

                // Reset textarea height
                if (textareaRef.current) {
                    textareaRef.current.style.height = 'auto';
                }

                try {
                    // Ïã§Ï†ú OpenAI API Ìò∏Ï∂ú
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-5.1',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are an expert research assistant helping a researcher understand an academic paper in HCI (Human-Computer Interaction).

**Paper Content:**
${paperContent.replace(/<[^>]*>/g, '')}

**Your Role:**
- Provide clear, accurate, and insightful answers based on the paper
- Use specific examples and details from the paper when relevant
- Structure your responses well (use headings, bullet points, numbering when appropriate)
- If asked to summarize, focus on key contributions, methods, and findings
- If information is not in the paper, clearly state that
- Use Korean if the user asks in Korean, English if they ask in English
- Be concise but thorough - aim for clarity over length

**Response Format:**
Use markdown formatting for better readability:
- **Bold** for key terms or important points
- Bullet points for lists
- Code blocks for technical details if needed`
                                },
                                ...messages.map(msg => ({
                                    role: msg.role,
                                    content: msg.content
                                })),
                                {
                                    role: 'user',
                                    content: queryText
                                }
                            ],
                            max_completion_tokens: 16384,
                            temperature: 0.5
                        })
                    });

                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || 'API request failed');
                    }

                    const data = await response.json();
                    const simulatedResponse = data.choices[0].message.content;
                    const answerTime = Date.now();

                    const assistantMessage = {
                        role: 'assistant',
                        content: simulatedResponse,
                        timestamp: answerTime
                    };

                    setMessages(prev => [...prev, assistantMessage]);
                    
                    // Log to chatHistory
                    const qa = {
                        question: queryText,
                        questionTime: questionTime,
                        answer: simulatedResponse,
                        answerTime: answerTime,
                        responseTime: answerTime - questionTime
                    };
                    setChatHistory(prev => [...prev, qa]);
                    
                    logEvent('llm_answer_received', { 
                        question: queryText,
                        answer: simulatedResponse,
                        responseTime: answerTime - questionTime,
                        timestamp: answerTime
                    });
                } catch (error) {
                    console.error('Error calling OpenAI API:', error);
                    // ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú
                    const errorMessage = {
                        role: 'assistant',
                        content: `Sorry, I encountered an error: ${error.message}. Please check the API key and try again.`,
                        timestamp: Date.now()
                    };
                    setMessages(prev => [...prev, errorMessage]);
                } finally {
                    setIsLoading(false);
                }
            };

            // Attach current paper PDF
            const attachCurrentPaperPDF = () => {
                console.log('üîç Debug - currentPaper:', currentPaper);
                console.log('üîç Debug - papers:', papers);

                const paper = papers.find(p => p.id === currentPaper);
                console.log('üîç Debug - found paper:', paper);

                if (!paper) {
                    console.error('‚ùå Paper not found for ID:', currentPaper);
                    alert('ÌòÑÏû¨ ÎÖºÎ¨∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÎÖºÎ¨∏Ïù¥ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏùÑ Ïàò ÏûàÏäµÎãàÎã§.');
                    setShowPlusMenu(false);
                    return;
                }

                if (!paper.pdfUrl) {
                    console.error('‚ùå No PDF URL for paper:', paper.id);
                    alert('Ïù¥ ÎÖºÎ¨∏Ïùò PDF ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
                    setShowPlusMenu(false);
                    return;
                }

                const pdfFile = {
                    name: `${paper.id}.pdf`,
                    url: paper.pdfUrl,
                    type: 'application/pdf',
                    timestamp: Date.now()
                };

                setUploadedFiles(prev => [...prev, pdfFile]);
                logEvent('paper_pdf_attached', {
                    paperId: paper.id,
                    pdfUrl: paper.pdfUrl,
                    timestamp: Date.now()
                });
                console.log(`üìé [PDF ATTACHED] ${pdfFile.name} (URL: ${paper.pdfUrl})`);
                setShowPlusMenu(false);
            };

            // Remove file from attachment list
            const removeFile = (index) => {
                setUploadedFiles(prev => prev.filter((_, i) => i !== index));
            };

            // Markdown renderer with nested lists, tables, blockquotes, and horizontal rules
            const renderMarkdown = (text) => {
                if (!text) return '';

                let html = text;

                // Code blocks (```code```) - process first to avoid interference
                html = html.replace(/```([^`]+)```/g, '<pre style="background: #f5f5f5; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 8px 0;"><code>$1</code></pre>');

                // Inline code (`code`)
                html = html.replace(/`([^`]+)`/g, '<code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">$1</code>');

                // Bold (**text** or __text__)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');

                // Italic (*text* or _text_) - be careful not to match list items
                html = html.replace(/(?<![*\-])\*([^\*\n]+)\*(?!\*)/g, '<em>$1</em>');
                html = html.replace(/(?<!_)_([^_\n]+)_(?!_)/g, '<em>$1</em>');

                // Headers (# text) - process from most specific (####) to least specific (#)
                html = html.replace(/^#### (.+)$/gm, '<h4 style="font-size: 1.1em; font-weight: 600; margin: 12px 0 6px 0;">$1</h4>');
                html = html.replace(/^### (.+)$/gm, '<h3 style="font-size: 1.2em; font-weight: 600; margin: 14px 0 8px 0;">$1</h3>');
                html = html.replace(/^## (.+)$/gm, '<h2 style="font-size: 1.35em; font-weight: 600; margin: 16px 0 10px 0;">$1</h2>');
                html = html.replace(/^# (.+)$/gm, '<h1 style="font-size: 1.5em; font-weight: 600; margin: 16px 0 10px 0;">$1</h1>');

                // Horizontal rule (---, ***, ___)
                html = html.replace(/^[-*_]{3,}$/gm, '<hr style="border: none; border-top: 1px solid #ddd; margin: 16px 0;">');

                // Process tables
                html = html.replace(/(?:^|\n)((?:\|[^\n]+\|\n)+)/g, (match, tableContent) => {
                    const rows = tableContent.trim().split('\n');
                    if (rows.length < 2) return match;

                    let tableHtml = '<table style="border-collapse: collapse; margin: 12px 0; width: 100%;">';

                    rows.forEach((row, rowIndex) => {
                        // Skip separator row (|---|---|)
                        if (row.match(/^\|[\s\-:]+\|$/)) return;

                        const cells = row.split('|').filter(cell => cell !== '');
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f5f5f5;' : '';

                        tableHtml += '<tr>';
                        cells.forEach(cell => {
                            tableHtml += `<${tag} style="border: 1px solid #ddd; padding: 8px; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHtml += '</tr>';
                    });

                    tableHtml += '</table>';
                    return tableHtml;
                });

                // Process lines for lists and blockquotes
                const lines = html.split('\n');
                let result = [];
                let listStack = []; // Track nested list levels: [{type: 'ul'|'ol', indent: number}]
                let inBlockquote = false;

                const getIndentLevel = (line) => {
                    const match = line.match(/^(\s*)/);
                    return match ? Math.floor(match[1].length / 2) : 0;
                };

                const closeListsToLevel = (targetLevel) => {
                    while (listStack.length > targetLevel) {
                        const list = listStack.pop();
                        result.push(list.type === 'ul' ? '</ul>' : '</ol>');
                    }
                };

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const indent = getIndentLevel(line);
                    const trimmedLine = line.trim();

                    // Blockquote (> text)
                    const blockquoteMatch = trimmedLine.match(/^>\s*(.*)$/);
                    if (blockquoteMatch) {
                        closeListsToLevel(0);
                        if (!inBlockquote) {
                            result.push('<blockquote style="border-left: 4px solid #ddd; margin: 12px 0; padding: 8px 16px; color: #666; background: #f9f9f9;">');
                            inBlockquote = true;
                        }
                        result.push(blockquoteMatch[1] + '<br>');
                        continue;
                    } else if (inBlockquote) {
                        result.push('</blockquote>');
                        inBlockquote = false;
                    }

                    // Unordered list (- or *)
                    const unorderedMatch = trimmedLine.match(/^[\-\*]\s+(.+)$/);
                    // Ordered list (1. 2. etc)
                    const orderedMatch = trimmedLine.match(/^\d+\.\s+(.+)$/);

                    if (unorderedMatch) {
                        const targetLevel = indent + 1;

                        // Close lists that are deeper than current
                        closeListsToLevel(targetLevel);

                        // Open new list if needed
                        if (listStack.length < targetLevel || listStack[listStack.length - 1]?.type !== 'ul') {
                            if (listStack.length === targetLevel && listStack[listStack.length - 1]?.type === 'ol') {
                                result.push('</ol>');
                                listStack.pop();
                            }
                            result.push('<ul style="margin: ' + (listStack.length === 0 ? '8px' : '4px') + ' 0; padding-left: 24px; list-style-type: disc;">');
                            listStack.push({ type: 'ul', indent });
                        }
                        result.push('<li style="margin: 4px 0;">' + unorderedMatch[1] + '</li>');
                    } else if (orderedMatch) {
                        const targetLevel = indent + 1;

                        closeListsToLevel(targetLevel);

                        if (listStack.length < targetLevel || listStack[listStack.length - 1]?.type !== 'ol') {
                            if (listStack.length === targetLevel && listStack[listStack.length - 1]?.type === 'ul') {
                                result.push('</ul>');
                                listStack.pop();
                            }
                            result.push('<ol style="margin: ' + (listStack.length === 0 ? '8px' : '4px') + ' 0; padding-left: 24px; list-style-type: decimal;">');
                            listStack.push({ type: 'ol', indent });
                        }
                        result.push('<li style="margin: 4px 0;">' + orderedMatch[1] + '</li>');
                    } else {
                        // Not a list item - close all lists
                        closeListsToLevel(0);

                        if (trimmedLine === '') {
                            result.push('<br>');
                        } else if (!trimmedLine.startsWith('<')) {
                            // Regular text (not HTML tag)
                            result.push(line + '<br>');
                        } else {
                            result.push(line);
                        }
                    }
                }

                // Close any remaining open elements
                closeListsToLevel(0);
                if (inBlockquote) result.push('</blockquote>');

                html = result.join('');

                return html;
            };

            // Start experiment
            const startExperiment = async () => {
                if (!participantId || !currentPaper) {
                    alert('Please fill in all fields');
                    return;
                }
                
                // Load paper content and metadata
                const paper = papers.find(p => p.id === currentPaper);
                if (paper && paper.url) {
                    try {
                        // Load HTML content
                        const response = await fetch(paper.url);
                        const html = await response.text();
                        
                        // Parse HTML and extract prose content
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const proseDiv = doc.querySelector('.prose');
                        
                        if (proseDiv) {
                            console.log('üîç [Reading Phase] Extracted HTML contains h3 tags:', proseDiv.innerHTML.includes('<h3'));
                            console.log('üîç [Reading Phase] Number of h3 tags:', (proseDiv.innerHTML.match(/<h3/g) || []).length);
                            setPaperContent(proseDiv.innerHTML);

                            // Calculate actual section boundaries from DOM
                            setTimeout(() => {
                                const sections = document.querySelectorAll('[data-section]');
                                const container = document.getElementById('paper-content') || document.querySelector('.prose');

                                console.log('üîç [Reading Phase] Found sections:', sections.length);
                                console.log('üîç [Reading Phase] Section elements:', Array.from(sections).map(s => ({ tag: s.tagName, name: s.getAttribute('data-section') })));

                                if (sections.length > 0 && container) {
                                    const newBoundaries = {};
                                    
                                    sections.forEach((section, index) => {
                                        const sectionName = section.getAttribute('data-section');
                                        const sectionTop = section.offsetTop;
                                        
                                        let sectionEnd;
                                        if (index < sections.length - 1) {
                                            sectionEnd = sections[index + 1].offsetTop;
                                        } else {
                                            sectionEnd = container.scrollHeight;
                                        }
                                        
                                        newBoundaries[sectionName] = {
                                            start: sectionTop,
                                            end: sectionEnd
                                        };
                                    });
                                    
                                    setSectionBoundaries(newBoundaries);
                                    console.log('üìä Section Boundaries loaded:', newBoundaries);
                                    
                                    // Set initial section
                                    const firstSection = Object.keys(newBoundaries)[0];
                                    if (firstSection) {
                                        setCurrentSection(firstSection);
                                    }
                                } else {
                                    console.warn('‚ö†Ô∏è No sections found in paper');
                                }
                            }, 500); // Wait for DOM to render
                            
                        } else {
                            setPaperContent('<p>Error: Could not load paper content</p>');
                        }
                    } catch (error) {
                        console.error('Error loading paper:', error);
                        setPaperContent('<p>Error loading paper. Please check the file path.</p>');
                    }
                }
                
                setPhase('reading');
                setReadingActive(true);
                lastActivityTimeRef.current = Date.now(); // Initialize scroll timer
                
                // Firebase: Ïã§Ìóò Î¨∏ÏÑú ÏÉùÏÑ±
                try {
                    if (window.firebaseDb) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        await window.firebaseSetDoc(experimentRef, {
                            participantId: participantId,
                            sessionId: sessionId,
                            condition: condition,
                            paper: currentPaper,
                            startedAt: window.firebaseServerTimestamp(),
                            status: 'in_progress',
                            createdAt: Date.now()
                        });
                        
                        console.log('‚úÖ Experiment document created:', `users/${participantId}/experiments/${sessionId}`);
                    }
                } catch (error) {
                    console.error('‚ùå Failed to create experiment document:', error);
                }
                
                logEvent('experiment_start');
                logEvent('reading_phase_start');
            };

            // Complete reading phase
            const completeReading = async () => {
                setReadingActive(false);
                
                console.log(`üèÅ Completing reading phase...`);
                console.log(`   Active focus: ${activeFocus}`);
                console.log(`   Current section: ${currentSection}`);
                console.log(`   Last activity time: ${lastActivityTimeRef.current}`);

                // ÎßàÏßÄÎßâ Ïù¥Î≤§Ìä∏ Ï§ÄÎπÑ
                let finalEvent = null;

                // ÎßàÏßÄÎßâ ÏùΩÍ∏∞ Íµ¨Í∞Ñ Í∞ïÏ†ú Î°úÍπÖ (Finish Î≤ÑÌäº ÎàÑÎ•¥Í∏∞ ÏßÅÏ†Ñ)
                // ReadingÏóê Ìè¨Ïª§Ïä§ÎêòÏñ¥ ÏûàÏùÑ ÎïåÎßå Í∏∞Î°ù
                if (activeFocus === 'reading') {
                    const now = Date.now();
                    const finalPauseDuration = now - lastActivityTimeRef.current;
                    
                    console.log(`   Final pause duration: ${finalPauseDuration}ms`);
                    
                    let finalClassification;
                    if (finalPauseDuration > 5000) {
                        finalClassification = 'reading';
                    } else if (finalPauseDuration > 2000) {
                        finalClassification = 'scanning';
                    } else {
                        finalClassification = 'scrolling';
                    }

                    // Í≥†Ïú† ID ÏÉùÏÑ±
                    eventIdCounter.current++;
                    const finalEventId = `${sessionId}_${eventIdCounter.current}`;

                    // ÎßàÏßÄÎßâ Ïù¥Î≤§Ìä∏ Í∞ùÏ≤¥ ÏÉùÏÑ±
                    finalEvent = {
                        eventId: finalEventId,
                        timestamp: now,
                        eventType: 'scroll_action',
                        phase: 'reading',
                        timeSinceLast: now - lastEventTime.current,
                        participantId,
                        sessionId,
                        condition,
                        paper: currentPaper,
                        scrollY: pdfContainerRef.current?.scrollTop || 0,
                        sectionBeforeScroll: currentSection,
                        sectionAfterScroll: currentSection,
                        classification: finalClassification,
                        pauseDuration: finalPauseDuration,
                        scrollDuration: 0,
                        isFinalSegment: true
                    };
                    
                    // StateÏóêÎèÑ Ï∂îÍ∞Ä (UIÏö©)
                    setEvents(prev => [...prev, finalEvent]);
                    
                    // localStorageÏóêÎèÑ Ï∂îÍ∞Ä
                    const storedEvents = JSON.parse(localStorage.getItem('experimentEvents') || '[]');
                    storedEvents.push(finalEvent);
                    localStorage.setItem('experimentEvents', JSON.stringify(storedEvents));
                    
                    console.log(`üèÅ [FINAL ${finalClassification.toUpperCase()}] pause: ${finalPauseDuration}ms at "${currentSection}"`);
                } else {
                    // ChatÏóê Ìè¨Ïª§Ïä§ÎêòÏñ¥ ÏûàÎã§Î©¥ LLM duration Í∏∞Î°ù
                    const now = Date.now();
                    const finalLLMDuration = now - focusStartTimeRef.current;

                    console.log(`   Final LLM duration: ${finalLLMDuration}ms`);

                    // Í≥†Ïú† ID ÏÉùÏÑ±
                    eventIdCounter.current++;
                    const finalEventId = `${sessionId}_${eventIdCounter.current}`;

                    finalEvent = {
                        eventId: finalEventId,
                        timestamp: now,
                        eventType: 'focus_switch',
                        phase: 'reading',
                        timeSinceLast: now - lastEventTime.current,
                        participantId,
                        sessionId,
                        condition,
                        paper: currentPaper,
                        from: activeFocus,
                        to: 'finish',
                        timeOnPreviousFocus: finalLLMDuration,
                        classification: 'llm',
                        llmDuration: finalLLMDuration,
                        isFinalSegment: true
                    };

                    setEvents(prev => [...prev, finalEvent]);

                    const storedEvents = JSON.parse(localStorage.getItem('experimentEvents') || '[]');
                    storedEvents.push(finalEvent);
                    localStorage.setItem('experimentEvents', JSON.stringify(storedEvents));

                    console.log(`üèÅ [FINAL LLM] duration: ${finalLLMDuration}ms`);
                }

                // Record final focus time
                const elapsed = Date.now() - focusStartTimeRef.current;
                const finalFocusTimes = {
                    ...focusTimes,
                    [activeFocus]: focusTimes[activeFocus] + elapsed
                };
                
                const readingDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.reading = readingDuration;
                
                // Classification ÏöîÏïΩ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                const scrollEvents = events.filter(e => e.eventType === 'scroll_action');
                const classificationSummary = {
                    reading: {
                        count: scrollEvents.filter(e => e.classification === 'reading').length,
                        totalDuration: scrollEvents
                            .filter(e => e.classification === 'reading')
                            .reduce((sum, e) => sum + (e.pauseDuration || 0), 0),
                        sections: [...new Set(scrollEvents
                            .filter(e => e.classification === 'reading')
                            .map(e => e.sectionBeforeScroll))]
                    },
                    scanning: {
                        count: scrollEvents.filter(e => e.classification === 'scanning').length,
                        totalDuration: scrollEvents
                            .filter(e => e.classification === 'scanning')
                            .reduce((sum, e) => sum + (e.pauseDuration || 0), 0),
                        sections: [...new Set(scrollEvents
                            .filter(e => e.classification === 'scanning')
                            .map(e => e.sectionBeforeScroll))]
                    },
                    scrolling: {
                        count: scrollEvents.filter(e => e.classification === 'scrolling').length,
                        totalDuration: scrollEvents
                            .filter(e => e.classification === 'scrolling')
                            .reduce((sum, e) => sum + (e.pauseDuration || 0), 0),
                        sections: [...new Set(scrollEvents
                            .filter(e => e.classification === 'scrolling')
                            .map(e => e.sectionBeforeScroll))]
                    }
                };
                
                // ÏÑπÏÖòÎ≥Ñ Î∂ÑÏÑù
                const sectionAnalysis = {};
                scrollEvents.forEach(e => {
                    const section = e.sectionBeforeScroll;
                    if (!sectionAnalysis[section]) {
                        sectionAnalysis[section] = { reading: 0, scanning: 0, scrolling: 0 };
                    }
                    sectionAnalysis[section][e.classification] += (e.pauseDuration || 0);
                });
                
                logEvent('reading_phase_complete', {
                    duration: readingDuration,
                    focusTimes: finalFocusTimes,
                    chatHistory: chatHistory,
                    classificationSummary,
                    sectionAnalysis
                });
                
                // Firebase: Ïã§Ìóò Î¨∏ÏÑúÏóê reading ÏöîÏïΩ + Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥ Ï†ÄÏû•
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        // Reading phaseÏùò Î™®Îì† Ïù¥Î≤§Ìä∏ ÌïÑÌÑ∞ÎßÅ (ÎßàÏßÄÎßâ Ïù¥Î≤§Ìä∏ Ìè¨Ìï®)
                        let readingEvents = events.filter(e =>
                            e.phase === 'reading' &&
                            (e.eventType === 'scroll_action' ||
                             e.eventType === 'focus_switch' ||
                             e.eventType === 'tab_switch' ||
                             e.eventType === 'llm_activity' ||
                             e.eventType === 'text_selection')
                        );

                        // ÎßàÏßÄÎßâ Ïù¥Î≤§Ìä∏ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï∂îÍ∞Ä
                        if (finalEvent) {
                            readingEvents = [...readingEvents, finalEvent];
                            console.log(`   Including final event in Firebase save. Total events: ${readingEvents.length}`);
                        }

                        const updateData = {
                            'reading.duration': readingDuration,
                            'reading.focusTimes': finalFocusTimes,
                            'reading.classificationSummary': classificationSummary,
                            'reading.sectionAnalysis': sectionAnalysis,
                            'reading.events': readingEvents, // Î™®Îì† Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥Î°ú Ï†ÄÏû•
                            'reading.completedAt': window.firebaseServerTimestamp()
                        };
                        
                        // with_llm Ï°∞Í±¥Ïù¥Î©¥ LLM interaction Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
                        if (condition === 'with_llm' && chatHistory.length > 0) {
                            updateData['llmInteraction.messages'] = chatHistory;
                            updateData['llmInteraction.totalQueries'] = chatHistory.length;
                            updateData['llmInteraction.avgResponseTime'] = chatHistory.length > 0
                                ? chatHistory.reduce((sum, qa) => sum + qa.responseTime, 0) / chatHistory.length
                                : 0;
                        }
                        
                        await window.firebaseUpdateDoc(experimentRef, updateData);
                        
                        console.log('‚úÖ Reading phase data saved (with', readingEvents.length, 'events)');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to save reading summary:', error);
                }
                
                setPhase('quiz-guide');
                logEvent('quiz_guide_shown');
            };

            // Handle quiz answer
            const handleQuizAnswer = (questionId, answer) => {
                setQuizAnswers(prev => ({ ...prev, [questionId]: answer }));
                logEvent('quiz_answer', { questionId, answer });
            };

            // Complete quiz phase
            const completeQuiz = async () => {
                setQuizActive(false);
                const quizDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.quiz = quizDuration;
                logEvent('quiz_phase_complete', { answers: quizAnswers, duration: quizDuration });
                
                // Firebase: Quiz Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        await window.firebaseUpdateDoc(experimentRef, {
                            'quiz.answers': quizAnswers,
                            'quiz.duration': quizDuration,
                            'quiz.submittedAt': window.firebaseServerTimestamp()
                        });
                        
                        console.log('‚úÖ Quiz data saved');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to save quiz data:', error);
                }
                
                setPhase('review-guide');
                logEvent('review_guide_shown');
            };

            // Handle review change
            const handleReviewChange = (field, value) => {
                setReviewData(prev => ({ ...prev, [field]: value }));
                logEvent('review_edit', { field, valueLength: value.length });
            };

            // Complete review phase
            const completeReview = async () => {
                setReviewActive(false);
                const reviewDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.review = reviewDuration;
                logEvent('review_phase_complete', { reviewData, duration: reviewDuration });
                
                // Firebase: Review Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Î∞è Ïã§Ìóò ÏôÑÎ£å Ï≤òÎ¶¨
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        await window.firebaseUpdateDoc(experimentRef, {
                            'review.rating': reviewData.rating,
                            'review.strengths': reviewData.strengths,
                            'review.weaknesses': reviewData.weaknesses,
                            'review.suggestions': reviewData.suggestions,
                            'review.duration': reviewDuration,
                            'review.submittedAt': window.firebaseServerTimestamp(),
                            'status': 'completed',
                            'completedAt': window.firebaseServerTimestamp()
                        });
                        
                        console.log('‚úÖ Experiment completed and saved');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to complete experiment:', error);
                }
                
                setPhase('complete');
                logEvent('experiment_complete');
            };

            // Export data
            const exportData = async () => {
                const experimentData = {
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    phases: {
                        reading: { 
                            completed: true,
                            duration: phaseTimers.current.reading
                        },
                        quiz: { 
                            completed: phase !== 'reading', 
                            answers: quizAnswers,
                            duration: phaseTimers.current.quiz
                        },
                        review: { 
                            completed: phase === 'complete', 
                            data: reviewData,
                            duration: phaseTimers.current.review
                        }
                    },
                    events,
                    messages: condition === 'with_llm' ? messages : [],
                    completedAt: new Date().toISOString()
                };

                // FirebaseÏóê Ï†ÑÏ≤¥ Ïã§Ìóò Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                try {
                    if (window.firebaseDb) {
                        await window.firebaseAddDoc(
                            window.firebaseCollection(window.firebaseDb, 'experiments'),
                            {
                                ...experimentData,
                                serverTimestamp: window.firebaseServerTimestamp()
                            }
                        );
                        console.log('FirebaseÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å');
                    }
                } catch (error) {
                    console.error('Firebase Ï†ÄÏû• Ïã§Ìå®:', error);
                }

                // Î°úÏª¨ JSON Îã§Ïö¥Î°úÎìú (Î∞±ÏóÖÏö©)
                const dataStr = JSON.stringify(experimentData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `experiment_${participantId}_${sessionId}.json`;
                link.click();
                
                alert('Data saved to Firebase and downloaded as backup!');
            };

            // SETUP PHASE
            if (phase === 'setup') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">PDF Reading Experiment</h1>
                                <p className="text-gray-600">LLM-Assisted Academic Paper Reading Study</p>
                            </div>
                            
                            <div className="space-y-5">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Participant ID *
                                    </label>
                                    <input
                                        type="text"
                                        value={participantId}
                                        onChange={(e) => setParticipantId(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                        placeholder="e.g., P001"
                                    />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Condition *
                                    </label>
                                    <select
                                        value={condition}
                                        onChange={(e) => setCondition(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="without_llm">Without LLM (Control)</option>
                                        <option value="with_llm">With LLM (Experimental)</option>
                                    </select>
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Select Paper *
                                    </label>
                                    <select
                                        value={currentPaper}
                                        onChange={(e) => setCurrentPaper(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="">Choose a paper...</option>
                                        {papers.map(paper => (
                                            <option key={paper.id} value={paper.id}>
                                                {paper.name}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <button
                                    onClick={startExperiment}
                                    disabled={!participantId || !currentPaper}
                                    className="w-full bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-medium transition-colors text-lg mt-6"
                                >
                                    Start Experiment
                                </button>

                                <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                                    <p className="text-sm text-gray-700">
                                        <strong>Experiment Structure:</strong><br/>
                                        1. Reading (30 min)<br/>
                                        2. Quiz (15 min, closed-book)<br/>
                                        3. Review Writing (30 min, open-book)
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // READING GUIDE PHASE
            if (phase === 'reading-guide') {
                const paper = papers.find(p => p.id === currentPaper);
                const conditionText = condition === 'with_llm' ? 'Reading with AI' : 'Reading without AI';

                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-3xl w-full">
                            <div className="text-center mb-8">
                                <div className="text-5xl mb-4">üìñ</div>
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">
                                    Session {sessionNumber} - ÎÖºÎ¨∏ ÏùΩÍ∏∞
                                </h1>
                            </div>

                            <div className="space-y-6 mb-8">
                                <div className="bg-blue-50 border-l-4 border-blue-500 p-4">
                                    <p className="text-sm text-blue-900">
                                        <strong>{conditionText}</strong> 
                                    </p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">ÎÖºÎ¨∏ Ï†úÎ™©</h3>
                                    <p className="text-gray-700">{paper?.name} ({paper?.year})</p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Ï†úÌïú ÏãúÍ∞Ñ</h3>
                                    <p className="text-3xl font-bold text-blue-600">20Î∂Ñ</p>
                                </div>

                                <div className="bg-yellow-50 border-l-4 border-yellow-500 p-4">
                                    <p className="text-sm text-yellow-900">
                                        <strong>Ï§ëÏöî:</strong> Ï£ºÏñ¥ÏßÑ ÎÖºÎ¨∏ÏùÑ ÏùΩÏñ¥Î≥∏ Ï†ÅÏù¥ ÏûàÎã§Î©¥ Ïó∞Íµ¨ÏûêÏóêÍ≤å ÎßêÌï¥Ï£ºÏÑ∏Ïöî.
                                    </p>
                                </div>
                            </div>

                            <button
                                onClick={() => {
                                    setPhase('reading');
                                    setReadingActive(true);
                                    logEvent('reading_started');
                                }}
                                className="w-full px-8 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-lg font-medium transition-colors"
                            >
                                ÏãúÏûëÌïòÍ∏∞ ‚Üí
                            </button>
                        </div>
                    </div>
                );
            }

            // READING PHASE
            if (phase === 'reading') {
                return (
                    <div className="h-screen flex flex-col bg-gray-100">
                        {/* Header with Timer */}
                        <div className="bg-white shadow-md px-6 py-4 flex items-center justify-between border-b-2 border-gray-200">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">
                                    [ÎÖºÎ¨∏ ÏùΩÍ∏∞] {papers.find(p => p.id === currentPaper)?.name} ({papers.find(p => p.id === currentPaper)?.year})
                                </h2>
                                <p className="text-sm text-gray-600">
                                    {participantId} | {condition === 'with_llm' ? 'With LLM' : 'Without LLM'} | Section: <strong>{currentSection}</strong>
                                </p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer
                                    seconds={20 * 60}
                                    isActive={readingActive}
                                    phase="reading"
                                    onComplete={() => alert('Reading time is up! Please proceed to the quiz.')}
                                />
                                <button
                                    onClick={() => setShowFinishPopup(true)}
                                    className="flex items-center space-x-2 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium"
                                >
                                    <CheckIcon />
                                    <span>Finish Reading</span>
                                </button>
                            </div>
                        </div>

                        {/* Main content */}
                        <div className="flex-1 flex overflow-hidden">
                            {condition === 'without_llm' ? (
                                // Without LLM: Centered with same width as with_llm condition
                                <div className="flex-1 bg-gray-50 flex flex-col overflow-hidden">
                                    <div
                                        ref={pdfContainerRef}
                                        onScroll={handleScroll}
                                        onMouseUp={handleTextSelection}
                                        className="flex-1 overflow-y-auto p-8"
                                    >
                                        <div className="w-full max-w-[900px] mx-auto bg-white shadow-xl rounded-lg p-12">
                                            <div
                                                id="paper-content"
                                                className="prose max-w-none"
                                                dangerouslySetInnerHTML={{ __html: paperContent || '<p>Loading paper...</p>' }}
                                            />
                                        </div>
                                    </div>
                                </div>
                            ) : (
                                // With LLM: Split screen layout with fixed paper width
                                <>
                                    {/* Left Panel - Reading */}
                                    <div
                                        className={`flex-1 bg-white flex flex-col overflow-hidden transition-all ${
                                            activeFocus === 'reading' ? 'border-4 border-purple-500' : 'border-4 border-transparent'
                                        }`}
                                        onMouseEnter={() => switchFocus('reading')}
                                    >
                                        <div
                                            ref={pdfContainerRef}
                                            onScroll={handleScroll}
                                            onMouseUp={handleTextSelection}
                                            className="flex-1 overflow-y-auto p-6"
                                        >
                                            <div className="w-full max-w-none">
                                                <div
                                                    id="paper-content"
                                                    className="prose max-w-none"
                                                    dangerouslySetInnerHTML={{ __html: paperContent || '<p>Loading paper...</p>' }}
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {/* Right Panel - Chat */}
                                    <div
                                        className={`flex-1 bg-white flex flex-col overflow-hidden transition-all ${
                                            activeFocus === 'chat' ? 'border-4 border-purple-500' : 'border-4 border-transparent'
                                        }`}
                                        onMouseEnter={() => switchFocus('chat')}
                                    >
                            {/* Chat UI Content */}
                            {condition === 'with_llm' && (
                                <div className="flex-1 bg-white flex flex-col overflow-hidden">
                                    {/* LLM Assistant header */}
                                    <div className="px-4 py-3 border-b bg-white flex items-center justify-between">
                                        <div className="flex items-center space-x-2">
                                            <span className="text-xl font-semibold">LLM Assistant</span>
                                        </div>
                                        <button
                                            onClick={() => {
                                                if (messages.length > 0 && !window.confirm('ÏÉàÎ°úÏö¥ Ï±ÑÌåÖÏùÑ ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå? ÌòÑÏû¨ ÎåÄÌôî ÎÇ¥Ïö©ÏùÄ Ïú†ÏßÄÎê©ÎãàÎã§.')) {
                                                    return;
                                                }
                                                setMessages([]);
                                                setInputMessage('');
                                                logEvent('new_chat_started', { previousMessageCount: messages.length });
                                            }}
                                            className="px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors flex items-center space-x-2"
                                        >
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                            </svg>
                                            <span>New Chat</span>
                                        </button>
                                    </div>

                                    <div className="flex-1 overflow-y-auto bg-white">
                                        {messages.length === 0 ? (
                                            <div className="text-center text-gray-500 mt-12">
                                                <div className="text-4xl mb-4">üí¨</div>
                                                <p className="font-medium">Ask me anything!</p>
                                                <p className="text-sm mt-2 text-gray-400">ÎÖºÎ¨∏Ïóê ÎåÄÌï¥ ÏßàÎ¨∏ÌïòÍ±∞ÎÇò ÎèÑÏõÄÏùÑ ÏöîÏ≤≠ÌïòÏÑ∏Ïöî</p>
                                            </div>
                                        ) : (
                                            <div className="space-y-6 p-4">
                                                {messages.map((msg, idx) => (
                                                    <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                        <div className={`flex items-start space-x-3 max-w-[85%]`}>
                                                            {msg.role === 'assistant' && (
                                                                <div className="flex-shrink-0 w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center text-white font-semibold">
                                                                    AI
                                                                </div>
                                                            )}
                                                            <div className={`rounded-2xl px-5 py-3 ${
                                                                msg.role === 'user'
                                                                    ? 'bg-blue-600 text-white'
                                                                    : 'bg-gray-100 text-gray-900'
                                                            }`}>
                                                                {msg.role === 'assistant' ? (
                                                                    <div
                                                                        className="text-sm leading-relaxed"
                                                                        dangerouslySetInnerHTML={{ __html: renderMarkdown(msg.content) }}
                                                                    />
                                                                ) : (
                                                                    <p className="text-sm leading-relaxed whitespace-pre-wrap">{msg.content}</p>
                                                                )}
                                                            </div>
                                                            {msg.role === 'user' && (
                                                                <div className="flex-shrink-0 w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-white font-semibold">
                                                                    U
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                ))}
                                                {isLoading && (
                                                    <div className="flex justify-start">
                                                        <div className="flex items-start space-x-3 max-w-[85%]">
                                                            <div className="flex-shrink-0 w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center text-white font-semibold">
                                                                AI
                                                            </div>
                                                            <div className="bg-gray-100 rounded-2xl px-5 py-3">
                                                                <div className="flex space-x-2">
                                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0ms'}}></div>
                                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '150ms'}}></div>
                                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '300ms'}}></div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                <div ref={chatMessagesEndRef} />
                                            </div>
                                        )}
                                    </div>

                                    {/* LLM Assistant Input Area */}
                                    <div className="p-6 border-t bg-white">
                                        <div className="max-w-3xl mx-auto">
                                            {/* Attached Files Display */}
                                            {uploadedFiles.length > 0 && (
                                                <div className="mb-3 flex flex-wrap gap-2">
                                                    {uploadedFiles.map((file, idx) => (
                                                        <div key={idx} className="flex items-center space-x-2 bg-blue-50 text-blue-700 px-3 py-2 rounded-lg text-sm">
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
                                                            </svg>
                                                            <span className="font-medium">{file.name}</span>
                                                            <button
                                                                type="button"
                                                                onClick={() => removeFile(idx)}
                                                                className="text-blue-500 hover:text-blue-700 ml-1"
                                                            >
                                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                                </svg>
                                                            </button>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}

                                            <form onSubmit={handleSendMessage} className="relative">
                                                <div className="flex items-center border border-gray-300 rounded-3xl bg-gray-50 shadow-sm hover:shadow-md transition-shadow focus-within:border-gray-400">
                                                    {/* Plus Button with Menu */}
                                                    <div className="relative">
                                                        <button
                                                            type="button"
                                                            onClick={() => setShowPlusMenu(!showPlusMenu)}
                                                            className="p-3 hover:bg-gray-200 rounded-full transition-colors ml-2"
                                                        >
                                                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                                            </svg>
                                                        </button>

                                                        {/* Plus Menu Popup */}
                                                        {showPlusMenu && (
                                                            <div className="absolute bottom-full left-0 mb-2 w-64 bg-white rounded-lg shadow-2xl border border-gray-200 py-2 z-50">
                                                                {(() => {
                                                                    const currentPaperData = papers.find(p => p.id === currentPaper);
                                                                    const hasPDF = currentPaperData && currentPaperData.pdfUrl;

                                                                    return (
                                                                        <button
                                                                            type="button"
                                                                            onClick={attachCurrentPaperPDF}
                                                                            disabled={!hasPDF}
                                                                            className={`w-full px-4 py-3 text-left flex items-center space-x-3 transition-colors ${
                                                                                hasPDF
                                                                                    ? 'hover:bg-gray-50 text-gray-800'
                                                                                    : 'opacity-50 cursor-not-allowed text-gray-400'
                                                                            }`}
                                                                        >
                                                                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
                                                                            </svg>
                                                                            <span className="font-medium">
                                                                                {hasPDF ? 'ÎÖºÎ¨∏ PDF Ï≤®Î∂Ä' : 'ÎÖºÎ¨∏ PDF ÏóÜÏùå'}
                                                                            </span>
                                                                        </button>
                                                                    );
                                                                })()}
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* Input Field */}
                                                    <textarea
                                                        ref={textareaRef}
                                                        value={inputMessage}
                                                        onChange={handleTextareaChange}
                                                        onKeyDown={handleChatKeyDown}
                                                        placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Shift+Enter: Ï§ÑÎ∞îÍøà)"
                                                        className="flex-1 px-4 py-3 bg-transparent focus:outline-none text-gray-900 placeholder-gray-500 resize-none overflow-y-auto"
                                                        style={{maxHeight: '264px', minHeight: '24px', lineHeight: '24px'}}
                                                        rows={1}
                                                        disabled={isLoading}
                                                    />

                                                    {/* Send Button */}
                                                    <button
                                                        type="submit"
                                                        disabled={isLoading || !inputMessage.trim()}
                                                        className="p-2 mr-2 rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                                                    >
                                                        <div className={`w-8 h-8 rounded-full flex items-center justify-center transition-colors ${
                                                            inputMessage.trim() ? 'bg-black text-white' : 'bg-gray-300 text-gray-500'
                                                        }`}>
                                                            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                                                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                                            </svg>
                                                        </div>
                                                    </button>
                                                </div>
                                            </form>
                                        </div>
                                    </div>
                                </div>
                            )}
                                    </div>
                                </>
                            )}
                        </div>

                        {/* Finish Reading Popup */}
                        {showFinishPopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">Î¶¨Îî© ÏÑ∏ÏÖòÏùÑ ÎÅùÎÇºÍπåÏöî?</h3>
                                    <p className="text-gray-600 mb-6">
                                        Î¶¨Îî© ÏÑ∏ÏÖòÏùÑ Ï¢ÖÎ£åÌïòÍ≥† Îã§Ïùå Îã®Í≥ÑÎ°ú ÏßÑÌñâÌï©ÎãàÎã§.
                                    </p>
                                    <div className="flex space-x-4">
                                        <button
                                            onClick={() => setShowFinishPopup(false)}
                                            className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium transition-colors"
                                        >
                                            Ï∑®ÏÜå
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowFinishPopup(false);
                                                completeReading();
                                            }}
                                            className="flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium transition-colors"
                                        >
                                            ÌôïÏù∏
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // QUIZ GUIDE PHASE
            if (phase === 'quiz-guide') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-3xl w-full">
                            <div className="text-center mb-8">
                                <div className="text-5xl mb-4">üìù</div>
                                <p className="text-lg text-gray-600">Session {sessionNumber}</p>
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">
                                     ÎÖºÎ¨∏ Ïù¥Ìï¥ÎèÑ ÌÄ¥Ï¶à
                                </h1>
                            </div>

                            <div className="space-y-6 mb-8">
                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">ÏïàÎÇ¥</h3>
                                    <p className="text-gray-700">
                                        <li>ÎÖºÎ¨∏ÏùÑ ÏùΩÍ≥† Ïù¥Ìï¥Ìïú ÎÇ¥Ïö©ÏùÑ Î∞îÌÉïÏúºÎ°ú ÏßàÎ¨∏Ïóê ÎãµÌï¥Ï£ºÏÑ∏Ïöî. (Í∞ùÍ¥ÄÏãù 8Î¨∏Ï†ú)</li>
                                        <li>ÎãµÏùÑ Í≥†Î•¥Í∏∞ Ïñ¥Î†§Ïö¥ Î¨∏Ï†úÎäî ÏÑ†ÏßÄ Í∞ÄÏö¥Îç∞ "Î™®Î¶Ñ"ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.</li>
                                    </p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Ï†úÌïú ÏãúÍ∞Ñ</h3>
                                    <p className="text-3xl font-bold text-purple-600">5Î∂Ñ</p>
                                </div>
                            </div>

                            <button
                                onClick={() => {
                                    setPhase('quiz');
                                    setQuizActive(true);
                                    phaseStartTime.current = Date.now();
                                    logEvent('quiz_phase_start');
                                }}
                                className="w-full px-8 py-4 bg-purple-600 text-white rounded-lg hover:bg-purple-700 text-lg font-medium transition-colors"
                            >
                                ÏãúÏûëÌïòÍ∏∞ ‚Üí
                            </button>
                        </div>
                    </div>
                );
            }

            // QUIZ PHASE
            if (phase === 'quiz') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between sticky top-0 z-50">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Session {sessionNumber} - ÎÖºÎ¨∏ Ïù¥Ìï¥ÎèÑ ÌÄ¥Ï¶à</h2>
                                <p className="text-sm text-gray-600">Closed-book</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer
                                    seconds={5 * 60}
                                    isActive={quizActive}
                                    phase="quiz"
                                    onComplete={() => alert('Quiz time is up!')}
                                />
                                <button
                                    onClick={() => setShowFinishPopup(true)}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Quiz
                                </button>
                            </div>
                        </div>

                        <div className="max-w-4xl mx-auto p-8">
                            <div className="bg-blue-50 border-l-4 border-blue-600 p-4 mb-6">
                                <p className="text-sm">
                                    <strong>ÏïàÎÇ¥: </strong>ÎÖºÎ¨∏ÏùÑ ÏùΩÍ≥† Ïù¥Ìï¥Ìïú ÎÇ¥Ïö©ÏùÑ Î∞îÌÉïÏúºÎ°ú ÏßàÎ¨∏Ïóê ÎãµÌï¥Ï£ºÏÑ∏Ïöî. (Í∞ùÍ¥ÄÏãù 8Î¨∏Ï†ú)
                                </p>
                            </div>

                            <div className="space-y-6">
                                {quizQuestions.map((q, idx) => (
                                    <div key={q.id} className="bg-white rounded-lg shadow-md p-6">
                                        <div className="flex items-start space-x-3 mb-4">
                                            <span className="flex-shrink-0 w-8 h-8 bg-blue-600 text-white rounded-full flex items-center justify-center font-bold">
                                                {idx + 1}
                                            </span>
                                            <div className="flex-1">
                                                <div className="flex items-center mb-2">
                                                    <p className="font-medium text-gray-900">{q.question}</p>
                                                </div>

                                                {q.type === 'multiple_choice' ? (
                                                    <div className="space-y-2 mt-4">
                                                        {q.options.map((option, optIdx) => (
                                                            <label key={optIdx} className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer border border-gray-200">
                                                                <input
                                                                    type="radio"
                                                                    name={`question-${q.id}`}
                                                                    value={option}
                                                                    checked={quizAnswers[q.id] === option}
                                                                    onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                                    className="w-4 h-4"
                                                                />
                                                                <span className="text-gray-700">{option}</span>
                                                            </label>
                                                        ))}
                                                        {/* Î™®Î¶Ñ option */}
                                                        <p className="text-xs text-gray-500 mt-3 mb-1 pl-1">ÎãµÏùÑ Í≥†Î•¥Í∏∞ Ïñ¥Î†µÎã§Î©¥ ÏïÑÎûò 'Î™®Î¶Ñ'ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.</p>
                                                        <label className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer border border-gray-200 border-dashed">
                                                            <input
                                                                type="radio"
                                                                name={`question-${q.id}`}
                                                                value="Î™®Î¶Ñ"
                                                                checked={quizAnswers[q.id] === 'Î™®Î¶Ñ'}
                                                                onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                                className="w-4 h-4"
                                                            />
                                                            <span className="text-gray-500">Î™®Î¶Ñ</span>
                                                        </label>
                                                    </div>
                                                ) : (
                                                    <div className="mt-4">
                                                        <textarea
                                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                                            rows="4"
                                                            placeholder="ÎãµÎ≥ÄÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
                                                            value={quizAnswers[q.id] === 'Î™®Î¶Ñ' ? '' : (quizAnswers[q.id] || '')}
                                                            onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                            disabled={quizAnswers[q.id] === 'Î™®Î¶Ñ'}
                                                        />
                                                        {/* Î™®Î¶Ñ option for short answer */}
                                                        <p className="text-xs text-gray-500 mt-3 mb-1 pl-1">ÎãµÏùÑ Í≥†Î•¥Í∏∞ Ïñ¥Î†µÎã§Î©¥ ÏïÑÎûò 'Î™®Î¶Ñ'ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.</p>
                                                        <label className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer border border-gray-200 border-dashed">
                                                            <input
                                                                type="checkbox"
                                                                checked={quizAnswers[q.id] === 'Î™®Î¶Ñ'}
                                                                onChange={(e) => handleQuizAnswer(q.id, e.target.checked ? 'Î™®Î¶Ñ' : '')}
                                                                className="w-4 h-4"
                                                            />
                                                            <span className="text-gray-500">Î™®Î¶Ñ</span>
                                                        </label>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-8 p-4 bg-gray-100 rounded-lg">
                                <p className="text-sm text-gray-600">
                                    Progress: {Object.keys(quizAnswers).length} / {quizQuestions.length} questions answered
                                </p>
                            </div>
                        </div>

                        {/* Finish Quiz Popup */}
                        {showFinishPopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">ÌÄ¥Ï¶à ÏÑ∏ÏÖòÏùÑ ÎÅùÎÇºÍπåÏöî?</h3>
                                    <p className="text-gray-600 mb-6">
                                        ÌÄ¥Ï¶à ÏÑ∏ÏÖòÏùÑ Ï¢ÖÎ£åÌïòÍ≥† Îã§Ïùå Îã®Í≥ÑÎ°ú ÏßÑÌñâÌï©ÎãàÎã§.
                                    </p>
                                    <div className="flex space-x-4">
                                        <button
                                            onClick={() => setShowFinishPopup(false)}
                                            className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium transition-colors"
                                        >
                                            Ï∑®ÏÜå
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowFinishPopup(false);
                                                completeQuiz();
                                            }}
                                            className="flex-1 px-4 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium transition-colors"
                                        >
                                            ÌôïÏù∏
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // REVIEW GUIDE PHASE
            if (phase === 'review-guide') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-50 to-teal-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-3xl w-full">
                            <div className="text-center mb-8">
                                <div className="text-5xl mb-4">‚úçÔ∏è</div>
                                <p className="text-lg text-gray-600">Session {sessionNumber}</p>
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">
                                     ÎÖºÎ¨∏ Î¶¨Î∑∞ ÏûëÏÑ±
                                </h1>
                            </div>
                            <div className="space-y-6 mb-8">
                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">ÏïàÎÇ¥</h3>
                                    <p className="text-gray-700">
                                        ÎÖºÎ¨∏ÏùÑ ÏùΩÍ≥† Ïù¥Ìï¥Ìïú ÎÇ¥Ïö©ÏùÑ Î∞îÌÉïÏúºÎ°ú Î¶¨Î∑∞Ïñ¥Ïùò Í¥ÄÏ†êÏóêÏÑú ÎÖºÎ¨∏ÏùÑ ÌèâÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.
                                    </p>
                                    <p className="text-gray-700">
                                        Í∞Å Ìï≠Î™©Ïóê ÎåÄÌïú Í∏ÄÏûê Ïàò Ï†úÌïúÏùÄ ÏóÜÏäµÎãàÎã§.
                                    </p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Ï†úÌïú ÏãúÍ∞Ñ</h3>
                                    <p className="text-3xl font-bold text-green-600">15Î∂Ñ</p>
                                </div>
                            </div>

                            <button
                                onClick={() => {
                                    setPhase('review');
                                    setReviewActive(true);
                                    phaseStartTime.current = Date.now();
                                    logEvent('review_phase_start');
                                }}
                                className="w-full px-8 py-4 bg-green-600 text-white rounded-lg hover:bg-green-700 text-lg font-medium transition-colors"
                            >
                                ÏãúÏûëÌïòÍ∏∞ ‚Üí
                            </button>
                        </div>
                    </div>
                );
            }

            // REVIEW PHASE
            if (phase === 'review') {
                return (
                    <div className="h-screen flex flex-col bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between flex-shrink-0">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Session {sessionNumber} - ÎÖºÎ¨∏ Î¶¨Î∑∞ ÏûëÏÑ±</h2>
                                <p className="text-sm text-gray-600">Open-book</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer
                                    seconds={15 * 60}
                                    isActive={reviewActive}
                                    phase="review"
                                    onComplete={() => alert('Review time is up!')}
                                />
                                <button
                                    onClick={() => setShowFinishPopup(true)}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Review
                                </button>
                            </div>
                        </div>

                        <div className="flex-1 overflow-hidden px-4 py-6">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 h-full">
                                {/* Paper (for reference) */}
                                <div className="bg-white rounded-lg shadow-md p-6 overflow-y-auto">
                                    <div className="mb-4 pb-4 border-b border-gray-200">
                                        <h3 className="text-lg font-bold text-gray-800">
                                            {papers.find(p => p.id === currentPaper)?.name} ({papers.find(p => p.id === currentPaper)?.year})
                                        </h3>
                                    </div>
                                    <div
                                        className="prose max-w-none"
                                        dangerouslySetInnerHTML={{ __html: paperContent }}
                                    />
                                </div>

                                {/* Review Form */}
                                <div className="overflow-y-auto">
                                    <div className="space-y-6">
                                    <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
                                        <p className="text-sm text-gray-700">
                                            <strong>ÏïàÎÇ¥:</strong> ÎÖºÎ¨∏ÏùÑ ÏùΩÍ≥† Ïù¥Ìï¥Ìïú ÎÇ¥Ïö©ÏùÑ Î∞îÌÉïÏúºÎ°ú Î¶¨Î∑∞Ïñ¥Ïùò Í¥ÄÏ†êÏóêÏÑú ÎÖºÎ¨∏ÏùÑ ÌèâÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî. Í∞Å Ìï≠Î™©Ïóê ÎåÄÌïú Í∏ÄÏûê Ïàò Ï†úÌïúÏùÄ ÏóÜÏäµÎãàÎã§.
                                        </p>
                                    </div>
                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-xl font-bold mb-4">Rating</h3>
                                        <div className="flex items-center space-x-4">
                                            {[1, 2, 3, 4, 5].map(rating => (
                                                <button
                                                    key={rating}
                                                    onClick={() => handleReviewChange('rating', rating)}
                                                    className={`w-12 h-12 rounded-full font-bold transition-colors ${
                                                        reviewData.rating === rating
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                    }`}
                                                >
                                                    {rating}
                                                </button>
                                            ))}
                                        </div>
                                            <p className="text-xs text-gray-700">
                                                1 = Strong Reject (Îß§Ïö∞ Î∂ÄÏ°±Ìï®) |
                                                2 = Weak Reject (Î∂ÄÏ°±Ìï®) |
                                                3 = Borderline (Î≥¥ÌÜµ) |
                                                4 = Weak Accept (Ï¢ãÏùå) |
                                                5 = Strong Accept (Îß§Ïö∞ Ïö∞ÏàòÌï®)
                                            </p>
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-1">Strengths</h3>
                                        <p className="text-gray-500 mb-3">Ïù¥ Ïó∞Íµ¨Ïùò Í∞ïÏ†êÏùÄ Î¨¥ÏóáÏûÖÎãàÍπå?</p>
                                        <textarea
                                            value={reviewData.strengths}
                                            onChange={(e) => handleReviewChange('strengths', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder=""
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-1">Weaknesses</h3>
                                        <p className="text-gray-500 mb-3">Ïù¥ Ïó∞Íµ¨Ïùò Ï£ºÏöî ÏïΩÏ†êÏù¥ÎÇò ÌïúÍ≥ÑÎäî Î¨¥ÏóáÏûÖÎãàÍπå?</p>
                                        <textarea
                                            value={reviewData.weaknesses}
                                            onChange={(e) => handleReviewChange('weaknesses', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder=""
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-1">Suggestions for Improvement</h3>
                                        <p className="text-gray-500 mb-3">Ï†ÄÏûêÎì§Ïù¥ Ïù¥ Ïó∞Íµ¨Î•º Ïñ¥ÎñªÍ≤å Í∞úÏÑ†Ìï† Ïàò ÏûàÏùÑÍπåÏöî?</p>
                                        <textarea
                                            value={reviewData.suggestions}
                                            onChange={(e) => handleReviewChange('suggestions', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder=""
                                        />
                                    </div>

                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Finish Review Popup */}
                        {showFinishPopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">Î¶¨Î∑∞ ÏÑ∏ÏÖòÏùÑ ÎÅùÎÇºÍπåÏöî?</h3>
                                    <p className="text-gray-600 mb-6">
                                        Î¶¨Î∑∞ ÏÑ∏ÏÖòÏùÑ Ï¢ÖÎ£åÌïòÍ≥† ÏÑ∏ÏÖòÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
                                    </p>
                                    <div className="flex space-x-4">
                                        <button
                                            onClick={() => setShowFinishPopup(false)}
                                            className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium transition-colors"
                                        >
                                            Ï∑®ÏÜå
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowFinishPopup(false);
                                                completeReview();
                                            }}
                                            className="flex-1 px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium transition-colors"
                                        >
                                            ÌôïÏù∏
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // COMPLETE PHASE
            if (phase === 'complete') {
                // Handle experiment mode: transition to post-survey after each session
                const handleComplete = () => {
                    if (mode === 'experiment') {
                        // Always go to post-survey after completing a session
                        const params = new URLSearchParams({
                            participantId,
                            condition,
                            sessionNumber: sessionNumber.toString(),
                            mode: 'experiment'
                        });
                        window.location.href = `post-survey.html?${params.toString()}`;
                    } else {
                        // Test mode: just export data
                        exportData();
                    }
                };

                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-12 max-w-2xl w-full text-center">
                            <div className="text-6xl mb-6">üéâ</div>
                            <h1 className="text-4xl font-bold text-gray-800 mb-4">
                                {mode === 'experiment' ? `Session ${sessionNumber} Ï¢ÖÎ£å!` : 'Ïã§Ìóò Ï¢ÖÎ£å!'}
                            </h1>
                            <p className="text-gray-600 mb-8">
                                ÏÑ∏ÏÖò {sessionNumber}Ïóê ÎåÄÌïú ÏÇ¨ÌõÑ ÏÑ§Î¨∏ÏùÑ ÏßÑÌñâÌï¥Ï£ºÏÑ∏Ïöî.
                            </p>

{/* <div className="bg-gray-50 rounded-lg p-6 mb-8 text-left">
                                <h3 className="font-bold text-lg mb-4">ÏöîÏïΩ</h3>
                                <div className="space-y-2 text-gray-700">
                                    <p>‚Ä¢ Ï∞∏Ïó¨Ïûê: <strong>{participantId}</strong></p>
                                    {mode === 'experiment' && <p>‚Ä¢ ÏÑ∏ÏÖò: <strong>{sessionNumber} / 2</strong></p>}
                                    <p>‚Ä¢ Ï°∞Í±¥: <strong>{condition === 'with_llm' ? 'Reading with AI' : 'AI ÏßÄÏõê X'}</strong></p>
                                    <p>‚Ä¢ ÎÖºÎ¨∏: <strong>{papers.find(p => p.id === currentPaper)?.name}</strong></p>
                                    <p>‚Ä¢ ÌÄ¥Ï¶à ÏùëÎãµ: <strong>{Object.keys(quizAnswers).length} / {quizQuestions.length}</strong></p>
                                    <p>‚Ä¢ Î¶¨Î∑∞ ÌèâÏ†ê: <strong>{reviewData.rating} / 5</strong></p>
                                    <p>‚Ä¢ Î°úÍ∑∏ Ïù¥Î≤§Ìä∏: <strong>{events.length}</strong></p>
                                </div>
                            </div> */}

                            <button
                                onClick={handleComplete}
                                className="px-8 py-4 bg-green-600 text-white rounded-lg hover:bg-green-700 text-lg font-medium"
                            >
                                {mode === 'experiment' ? 'ÏÇ¨ÌõÑ ÏÑ§Î¨∏ ÏãúÏûë ‚Üí' : 'Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú'}
                            </button>

                        </div>
                    </div>
                );
            }

            return null;
        }

        ReactDOM.render(<PDFReadingExperiment />, document.getElementById('root'));
    </script>
</body>
</html>