<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Reading Experiment</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Icons
        const SendIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const SearchIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
        );

        const ClockIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        );

        const CheckIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
        );

        // Timer Component
        function Timer({ seconds, onComplete, isActive, phase }) {
            const [timeLeft, setTimeLeft] = useState(seconds);

            useEffect(() => {
                // Reset timer when phase changes
                setTimeLeft(seconds);
            }, [phase, seconds]);

            useEffect(() => {
                if (!isActive) return;
                
                const interval = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            clearInterval(interval);
                            if (onComplete) onComplete();
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isActive, onComplete]);

            const minutes = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            const isLowTime = timeLeft < 300; // 5분 미만

            return (
                <div className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-mono text-lg ${
                    isLowTime ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700'
                }`}>
                    <ClockIcon />
                    <span>{String(minutes).padStart(2, '0')}:{String(secs).padStart(2, '0')}</span>
                </div>
            );
        }

        // Main Application Component
        function PDFReadingExperiment() {
            // Experiment flow state
            const [phase, setPhase] = useState('setup'); // setup, reading, quiz, review, complete
            const [participantId, setParticipantId] = useState('');
            const [condition, setCondition] = useState('without_llm');
            const [currentPaper, setCurrentPaper] = useState('');
            const [sessionId] = useState(`session_${Date.now()}`);

            // Reading phase state
            const [scrollPosition, setScrollPosition] = useState(0);
            const [currentSection, setCurrentSection] = useState('Introduction');
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedText, setSelectedText] = useState('');
            const [readingActive, setReadingActive] = useState(false);

            // Quiz phase state
            const [quizActive, setQuizActive] = useState(false);
            const [quizAnswers, setQuizAnswers] = useState({});

            // Review phase state
            const [reviewActive, setReviewActive] = useState(false);
            const [reviewData, setReviewData] = useState({
                rating: 3,
                strengths: '',
                weaknesses: '',
                suggestions: ''
            });

            // Chat state (for LLM condition)
            const [messages, setMessages] = useState([]);
            const [inputMessage, setInputMessage] = useState('');
            const [isLoading, setIsLoading] = useState(false);

            // Timer tracking
            const phaseStartTime = useRef(Date.now());
            const phaseTimers = useRef({
                reading: 0,
                quiz: 0,
                review: 0
            });

            // Logging state
            const [events, setEvents] = useState([]);
            const lastEventTime = useRef(Date.now());
            const pdfContainerRef = useRef(null);
            const scrollTimeoutRef = useRef(null);
            const lastScrollTimeRef = useRef(Date.now());
            const scrollStartTimeRef = useRef(null); // Track when scroll starts
            const isScrollingRef = useRef(false); // Track if currently scrolling

            // Papers
            const papers = [
    {
        "id": "chi2025-lbw-01",
        "name": "\"A Great Start, But...\": Evaluating LLM-Generated Mind Maps for Information Mapping in Video-Based Design",
        "url": "chi2025-lbw-01.pdf"
    }
];

const papersContent = {
  'chi2025-lbw-01': `
<h1 class="text-4xl font-bold mb-4">"A Great Start, But...": Evaluating LLM-Generated Mind Maps for Information Mapping in Video-Based Design</h1><h2 class="text-2xl font-bold mb-4 mt-8">Abstract</h2><p class="mb-4 text-justify">Extracting concepts and understanding relationships from videos is essential in Video-Based Design (VBD), where videos serve as a primary medium for exploration but require significant effort in managing meta-information. Mind maps, with their ability to visually organize complex data, offer a promising approach for structuring and analysing video content. Recent advancements in Large Language Models (LLMs) provide new opportunities for meta-information processing and visual understanding in VBD, yet their application remains underexplored. This study recruited 28 VBD practitioners to investigate the use of prompt-tuned LLMs for generating mind maps from ethnographic videos. Comparing LLM-generated mind maps with those created by professional designers, we evaluated rated scores, design effectiveness, and user experience across two contexts. Findings reveal that LLMs effectively capture central concepts but struggle with hierarchical organization and contextual grounding. We discuss trust, customization, and workflow integration as key factors to guide future research on LLM-supported information mapping in VBD.</p><div class="my-8 p-4 bg-gray-50 rounded-lg"><img alt="Both LLM- and human-generated mind maps were presented on a web-based platform (Fig.1a) for reviewing and editing design concepts during the lab study (Fig.1b)." class="max-w-full mx-auto shadow-lg rounded" src="../papers_images/chi2025-lbw-01/chiea25-455-fig1.jpg"/><p class="text-sm text-gray-600 text-center mt-2 italic">Both LLM- and human-generated mind maps were presented on a web-based platform (Fig.1a) for reviewing and editing design concepts during the lab study (Fig.1b).</p></div><p class="mb-4 text-justify">Both LLM- and human-generated mind maps were presented on a web-based platform (Fig.1a) for reviewing and editing design concepts during the lab study (Fig.1b).</p><h2 class="text-2xl font-bold mb-4 mt-8">1 Introduction</h2><p class="mb-4 text-justify">In recent years, design processes have increasingly incorporated diverse tools and methods. The accessibility of video recording devices has established video as a widely used medium in design. The approach, referred to as Video-Based Design (VBD), is employed to use videos to identify design challenges, draw inspiration, and develop effective solutions [24,26,30,31]. By leveraging ethnographic videos [20]—recordings of human behaviours and interactions with products in situated environments—VBD provides designers with a rich, contextual understanding of user experiences. These videos serve as valuable tools to uncover latent issues and inspire innovative ideas [31]. However, ethnographic videos often contain fragmented elements, such as user interactions, environmental contexts, and personal narratives, which require substantial effort for designers to organize and distill into actionable insights. As Ylirisku and Buur emphasized, VBD demands that designers navigate large volumes of video content, extract the essence from the ethnographic footage, and systematically organize their findings into design decisions [31]. Traditionally, the organizing process in design relies on documentation techniques such as empathy mapping [21], customer journey mapping [19], and experience mapping [22], where designers use structured tables and visual frameworks to consolidate and interpret their insights cohesively.</p><p class="mb-4 text-justify">Mind maps, on the other hand, act as a powerful alternative for managing complex information in this context. Their intuitive structure often enables users to integrate diverse data types and support for cognitive processes such as memory recall and association in tasks. As Kedaj et al. [11] stated, mind maps provide a visual representation of hierarchical relationships and associations which simplify and organize multifaceted data especially in professional tasks. The flexible connections between concepts in mind maps allow users to classify ideas based on semantic connections and enhance retention [35]. The use of mind maps for summarizing videos and enhancing professional tasks is increasingly prevalent. For instance, Siddarth et al. [27] developed a framework to generate hierarchical mind maps from video lectures which simplifies lecture content into organized structures to aid learning. Similarly, the pipeline introduced by Zhao and Yang [36] uses mind maps to organize users’ learnt knowledge with new concepts from tutorial videos to improve video-based learning. Additionally, Mammen et al. [15] demonstrated how mind maps can support qualitative data analysis by organizing video content using tools such as XMind into clear conceptual groupings for concepts.</p><p class="mb-4 text-justify">The rise of Large Language Models (LLMs) such as GPT-4 [16], have demonstrated significant potential in organizing and synthesizing complex information [5,37]. Prior research highlights the capabilities of LLMs in addressing challenges related to data integration, knowledge fusion, and information processing. For instance, Yin et al. explored how LLMs’ semantic reasoning abilities, combined with prompt instruction tuning, can enhance users’ decision-making by distilling critical information from heterogeneous data sources [29]. Similarly, Remadi et al. revealed that LLMs possess the capability to extract entities and resolve ambiguities within unstructured datasets [18]. Additionally, Zhang et al. introduced Video-LLaMA [34], an LLM framework capable of understanding content in videos. Similarly, Video-ChatGPT proposed by Maaz et al. has demonstrated how integrating video-adapted visual encoders with LLMs can enhance temporal and spatial understanding in video content, further highlighting the potential of LLMs in structuring and processing video-based data [14]. Their framework leverages an LLM model and enables the automatic generation of text-based descriptions from videos. Despite these contributions, prior research has not yet examined the application of LLMs to improve video understanding and information processing within the context of VBD.</p><p class="mb-4 text-justify">To explore the utilization of LLMs in design, we investigate their potential to streamline VBD by reducing low-level human effort in video understanding and fostering efficiency in collecting design concepts and their relationships to one another (design information mapping). Specifically, we focus on the application of LLM-generated mind maps—structured, visual tools that represent hierarchical information and relationships—to assist designers in synthesizing insights from ethnographic videos and organizing their design ideas on a unified platform. We address the following research questions:</p><p class="mb-4 text-justify">How are LLM-generated mind maps perceived compared to human-generated ones in information mapping of video-based design (VBD)?</p><p class="mb-4 text-justify">In what ways do LLM-generated mind maps differ from human-generated mind maps in the effectiveness of practising in VBD workflows?</p><p class="mb-4 text-justify">What impact do LLM-generated mind maps have on the designers’ acceptance and perceived usefulness compared to human-generated mind maps in aiding VBD?</p><p class="mb-4 text-justify">To answer the questions, we conducted a controlled experimental study involving 28 designers from a university in scenario-based VBD exercises. We compared LLM-generated mind maps to human-generated ones to evaluate the performance of designers’ information understanding and organizing processes in VBD. As results, all participants recognized the potential of LLM-generated mind maps to enhance efficiency and provide a starting point for VBD. Many appreciated their ability to automate the labour-intensive process of initial information capture which promoted ideation for higher-levelled tasks. Our findings also show that while LLM-generated mind maps offer significant advantages in automating data capture from ethnographic videos and providing a foundational structure, they face challenges in usability, organization, and decision-making support compared to human-generated maps. These insights showcase the great potential of LLMs in upscaling design processes while drastically reducing human effort. Specifically, compared to human-generated mind maps, LLM-generated maps are:1)More efficient in automating data capture but require more time for designers to edit and refinement.2)Less effective in organizing hierarchical structures.3)More demanding on cognitive load due to unstructured outputs, despite reducing initial manual effort.4)More reliant on trust, workflow integration, and human oversight to support effective decision-making.</p><h2 class="text-2xl font-bold mb-4 mt-8">2 Methodology</h2><p class="mb-4 text-justify">We conducted a within-subject experimental study over three weeks to examine how LLM-generated mind maps compare to human-generated mind maps in supporting information mapping of VBD. The independent variable was the type of mind map, which included two conditions: human-generated and LLM-generated. We developed a workflow using GPT-4o [16] to generate mind maps from videos and integrated them into a web-based tool. The tool includes a video player and an interface that allows users to view and modify the mind maps. This section details participants, experimental procedure, and measurements of performance in information mapping of VBD.</p><div class="my-8 p-4 bg-gray-50 rounded-lg"><img alt="Screenshots for the two contexts used in the study: Fig.2ashows a screenshot from a video about an autonomous taxi navigating a busy urban intersection with traffic signals, pedestrians, and other vehicles. Fig.2bshows a screenshot from a video showing a visually impaired user demonstrating accessibility tools on her phone, such as voiceover and screen reader functionalities, to navigate, type, and make a post on social media." class="max-w-full mx-auto shadow-lg rounded" src="../papers_images/chi2025-lbw-01/chiea25-455-fig2.jpg"/><p class="text-sm text-gray-600 text-center mt-2 italic">Screenshots for the two contexts used in the study: Fig.2ashows a screenshot from a video about an autonomous taxi navigating a busy urban intersection with traffic signals, pedestrians, and other vehicles. Fig.2bshows a screenshot from a video showing a visually impaired user demonstrating accessibility tools on her phone, such as voiceover and screen reader functionalities, to navigate, type, and make a post on social media.</p></div><p class="mb-4 text-justify">Screenshots for the two contexts used in the study: Fig.2ashows a screenshot from a video about an autonomous taxi navigating a busy urban intersection with traffic signals, pedestrians, and other vehicles. Fig.2bshows a screenshot from a video showing a visually impaired user demonstrating accessibility tools on her phone, such as voiceover and screen reader functionalities, to navigate, type, and make a post on social media.</p><p class="mb-4 text-justify">We recruited 28 design students (9 females and 19 males) from our university. The participants had an average age of 25.8 years (SD = 1.9) and an average of 5.1 years of design experience (SD = 2.6). We asked participants to self-evaluate their experience with VBD (VBD-XP) and their perceived reliability of LLMs in daily tasks. Regarding LLM reliability, participants rated it as "high (daily)" (n=9), "moderate (weekly)" (n=9), and "rare (occasionally)" (n=10). Results indicate that 53.6% of participants had high or moderate confidence in their VBD experience and 64.3% relied on LLMs in their daily or weekly practices.</p><p class="mb-4 text-justify">For design contexts, we selected two video scenarios each lasting 2 minutes and 20 seconds. These scenarios were carefully chosen based on professional designers’ input to represent two primary categories of video content commonly encountered by designers: 1) repetitive and informative point-of-view recordings, and 2) user-product interactions. As indicated in Fig.2, the chosen contexts were an autonomous car navigating an urban environment (Fig.2a) and a demonstration of a mobile phone accessibility features showed by a visually impaired user (fig.2b). Both videos were also standardized in bit rate to ensure consistency and fairness in participant evaluations. Based on the two selected videos, four mind maps were generated: one LLM-generated and one human-generated mind map for each video.</p><p class="mb-4 text-justify">To create the LLM-generated mind maps, we utilized</p><p class="mb-4 text-justify">blip2-opt-6.7b1, a state-of-the-art Vision-Language Model (VLM), to transcribe the video content into textual descriptions. These descriptions were then processed using GPT-4 [16] with prompt fine-tuning to convert them into mind maps. In the fine-tuning process, the video descriptions along with their corresponding scenario topics, were incorporated into the prompts (see Supplementary Text 1 in Appendix). We used prompts to instructed LLM to organize the video descriptions into a structured JSON format, which was then visualized as a mind map on the study platform. Additionally, for the human-generated mind maps, an independent designer was tasked with creating two mind maps for the two videos. The designer spent 10 minutes analysing each video to grasp its fundamental concepts. They then hand-drew a radial mind map on paper, which is a widely-used method in mind mapping to organize thoughts around a central theme [6]. The designer spent an additional 20 minutes to digitally transfer the mind map into a JSON file which is similar to the LLM-generated ones. To keep pairwise comparison in the study, both the human- and LLM-generated mind maps were designed to maintain a similar number of topics, keywords and links between them as closely as possible.</p><p class="mb-4 text-justify">We then developed a web-based platform (Fig.1a) consisting of two panels: a video player and a mind map editing panel. The video player on the left allowed participants to review and navigate the video content using controls such as play and pause. On the right side, the mind map editing panel displayed the mind maps visualized from JSON files. This panel enabled participants to actively edit the mind maps by moving nodes, modifying text, and adding or deleting links based on their understanding and interpretation of the video content and mind maps. Additionally, We included a countdown timer in the upper left corner to remind participants of the remaining time for their tasks.</p><p class="mb-4 text-justify">Due to time constraints in creating mind maps from scratch, our study used pre-created mind maps generated in advance using both LLM and human methods. Participants were asked to evaluate the mind maps from a designer’s perspective and rate them using a holistic scoring approach based on the established Mind Map Scoring Rubric (MMSR) [9]. The MMSR holistic scoring approach was chosen not only for its alignment with evaluators’ perceptions of critical factors like accuracy and proficiency [32] but also because it demonstrates higher inter-rater reliability for consistency compared to other qualitative rubrics [25]. In our study, we measured four key variables based on MMSR: 1) Identification of triggers (recognizing key concepts in the problem), 2) Development of concept links (exploring and expanding knowledge through valid connections), 3) Development of hierarchies (organizing concepts logically with core ideas at the center and specifics on the periphery), and 4) Identification of cross-links and relationship links (showing meaningful connections between different concepts and within a concept).</p><p class="mb-4 text-justify">We adopted the questionnaire of Unified Theory of Acceptance and Use of Technology 2 (UTAUT2) [23] to understand participant behaviour in mapping information. UTAUT2 measures participants’ willingness to integrate and use the mind maps on the study platform in their design workflows [23]. The questionnaire assessed responses across eight categories: Performance Expectancy (perceived benefits), Effort Expectancy (ease of use), Social Influence (impact of others’ opinions), Facilitating Conditions (availability of resources and support), behavioural Intention (intent to use), Hedonic Motivation (enjoyment), Price Value (cost-effectiveness), and Habit (routine use). In addition, as working memory is critical for information processing and decision-making in advanced tasks [17], we also assessed participants’ cognitive load using NASA-TLX questionnaire [8]. As an objective-based measurement of cognitive load [1], eye-tracking glasses (see Fig.1b) were also used to capture participants’ eye movements, including saccades (rapid movements between focus points), fixations (sustained focus on a single point), pupil sizes (diameter of pupils), and blinks (rapid eyelid closures).</p><p class="mb-4 text-justify">Overview of the experimental procedure with tasks performed by participants, and the measurements collected from preparation, main session and post-session of the study.</p><p class="mb-4 text-justify">As showed in Table1, the experiment consisted of three phases: preparation, the main session, and post-session surveys and interview. Participants began by signing consent forms and provided demographic information. A brief tutorial introduced participants to the study’s objectives, procedures, and the equipments used for the tasks. Participants were then assigned two tasks (A and B), which involved reviewing the two videos and editing the corresponding LLM- or human-generated mind maps. The order was predetermined using a randomized counterbalanced scheme. In the main session, participants began with Task A, where they first watched the assigned video (either context of autonomous car navigation or mobile phone accessibility features in Fig.2). They then reviewed the corresponding mind map A (either human- or LLM-generated) for 3 minutes. Participants then instructed to use the MMSR rubrics [9] to evaluate mind map A on the four categories mentioned in Section2.2.1on a scale from 1 to 100. Afterward, participants were given 10 minutes to modify mind map A using the web-based platform (see Section2.1). This process was repeated for Task B, where participants watched the second video (video B), reviewed, evaluated and edited the corresponding mind map B. Each task lasted approximately 20 minutes. By the end of the session, each participant was exposed to both versions of the mind maps (human- and LLM-generated) across the two video contexts. In the post-session, participants first completed the NASA-TLX questionnaire, followed by UTAUT2, and then interviewed about their experience in the study.</p><h2 class="text-2xl font-bold mb-4 mt-8">3 Results &amp; Discussion</h2><p class="mb-4 text-justify">We present the results of our experiment, which investigated the performance of information mapping using two methods across three dimensions: rating in effectiveness (RQ1), effectiveness in practice (RQ2), and use experience (RQ3). Statistical significance was determined using paired-samples t-tests and Wilcoxon signed-rank tests. Post-session interviews were analysed using thematic analysis [2] in ATLAS.ti to complement the quantitative results.</p><p class="mb-4 text-justify">We first analysed how participants evaluated LLM- and human-generated mind maps using the four categories from the MMSR described in Section2.2.1. No significant differences were found between LLM- and human-generated mind maps in three of the four categories:identification of triggers(Wilcoxon, Z = -0.054, p = 0.957),development of concept links(paired-samples t, t(27) = 0.478, p = 0.637), andidentification of cross-links and relationship links(Wilcoxon, Z = -1.058, p = 0.290). It indicates that LLM-generated mind maps effectively identify key concepts from VBD videos, expand relevant knowledge, and establish meaningful connections. In this case, LLMs can generate mind maps with comparable information extraction and linkage to those created by professional designers, while potentially requiring less effort and reducing fatigue. However, a significant difference was observed in the category of thedevelopment of hierarchies, which measures the ability to logically organize and categorize concepts in VBD videos’ information mapping. Human-generated mind maps scored significantly higher than LLM-generated ones (paired-samples t, t(27) = 2.456, p = 0.021). On average, human-generated mind maps scored 11.35% higher in this category (LLM-generated: 50.79 ± 23.87 points, human-generated: 62.14 ± 23.99 points). While LLM-generated mind maps perform well in capturing and linking concepts, they fall short in logically structuring information with core and relevant ideas. From our interviews, a similar pattern was observed. Participants (P4, P5, P11, P16, P18-21) noted that while LLM-generated mind maps enhance efficiency by providing a solid starting point with some connections between topics, human-generated information mapping still advantages in organizing clear categorization and deeper analysis on information.</p><p class="mb-4 text-justify">A Wilcoxon signed-rank test revealed that the time taken to analyse LLM- and human-generated mind maps in the study had no statistical significance (Z = -1.548, p =.122). However, a closer analysis showed that participants spent an additional 1.92 minutes on average editing LLM-generated mind maps compared to human-generated ones across the two design contexts (paired-samples t, t(28) = -2.278, p &lt;.015; LLM-generated: 7.39 ± 3.58 min, human-generated: 5.47 ± 2.95 min). Furthermore, as cognitive load plays a significant role in influencing the effectiveness of information processing during design tasks [3,4], we employed NASA-TLX questionnaire to measure participants’ working memory. A paired-samples t-test revealed no significant difference in self-reported cognitive load between the two conditions (t(27) = -1.291, p =.208). This indicates that participants perceived similar cognitive demands for both LLM- and human-generated mind maps. In addition to self-reported cognitive workload, we also used eye-tracking glasses to record participants’ eye movements while reviewing and editing the mind maps. Paired-samples t-tests revealed that no significant differences found in eye fixation duration (t(27) = -.045, p =.964), blink duration (t(27) =.999, p =.327), or changes in pupil diameter (t(27) = -.870, p =.196) between the two conditions. However, a significant difference was observed in eye saccade duration, with participants spending 3.92% more time sweeping through LLM-generated mind maps compared to human-generated ones (Wilcoxon, Z = -2.482, p =.013; LLM-generated: M = 60.96, SD = 21.76 ms; human-generated: M = 58.57, SD = 15.84 ms). Additionally, participants scanned the LLM-generated maps faster than the human-generated ones. A paired-samples t-test revealed that participants’ eye movement speed was 4.46% higher in the LLM-generated condition compared to the human-generated condition (t(27) = 2.113, p =.004; LLM-generated: M = 3674.97, SD = 561.03 px/s; human-generated: M = 3511.02, SD = 641.91 px/s). Participants were likely moving their gaze more quickly to navigate the elements in the LLM-generated maps. Together, these findings suggest that while the overall cognitive load was comparable across conditions, LLM-generated mind maps required more visual effort and faster scanning to interpret their contents effectively.</p><p class="mb-4 text-justify">The later interviews confirmed the efficiency of both mind map types in formalizing information for VBD. P6 noted the time-saving aspect of LLM-generated mind maps: “[P6] One click and you get a mind map; it’s valuable but needs better structure.” Conversely, P25 appreciated human-generated mind maps for reducing the effort of video analysis: “[P25] It saves time and avoids burnout.” Some participants (P1, P16, and P18) highlighted the redundant keywords in LLM-generated mind maps but acknowledged the flexibility to ignore irrelevant elements. However, our further qualitative results revealed that the lack of trust from participants in LLM-generated mind maps significantly influenced their editing time. This resulted in having more time for additional visual and logical verification in the editing process. P25 stated that they did not "trust" the LLM-generated outputs, while P17 emphasized the need for "further adjustments" to make the LLM-generated mind maps more usable. As P5 mentioned, “[P5] You need to verify what’s in the video and the (LLM-generated) mind map. You shouldn’t just blindly accept it.” Similarly, P9 emphasized that information mapping “should involve human input” to ensure the accuracy and reliability of the LLM-supported tool for VBD tasks.</p><p class="mb-4 text-justify">We then analysed self-rated scores from the UTAUT2 framework (see Section2.2.2) to measure participants’ acceptance and perceived usefulness of the two types of mind maps. In the categories ofsocial influence(Wilcoxon, Z = -.460, p =.646),facilitating conditions(Wilcoxon, Z = -.577, p =.564),hedonic motivation(Wilcoxon, Z = -.408, p =.683),price value(Wilcoxon, Z = -.277, p =.782), andhabit(Wilcoxon, Z = -1.112, p =.265), no significant differences were observed between LLM- and human-generated mind maps. However, paired-samples t-tests revealed significant differences between the two types of mind maps in the categories ofperformance expectancy (PE)(t(27) = 2.545, p =.017),effort expectancy (EE)(t(27) = 2.100, p =.045), andbehavioural intention (BI)(t(27) = 2.464, p =.020). Participants reported higher scores for human-generated mind maps compared to LLM-generated ones across these three categories: PE (human-generated: 4.13 ± 0.53; LLM-generated: 3.88 ± 0.70), EE (human-generated: 3.88 ± 0.78; LLM-generated: 3.64 ± 0.72), and BI (human-generated: 3.87 ± 0.15; LLM-generated: 3.59 ± 0.16). From our interviews, participants frequently (n=11) noted that LLM-generated mind maps lacked the intuitive structure and customization designers expect. Participants also observed that LLM-generated mind maps lacked the contextual understanding of design concepts typically found in human-generated maps. On the other hand, some participants (n=6) acknowledged the LLM’s ability to capture extensive details and make gathering and organizing data "way more efficient" (P2). Additionally, we also found that ease of use and familiarity with the mind-mapping tool significantly influenced participants’ perceptions of LLM-generated maps. P11 noted some initial difficulties in interpreting the LLM-generated mind maps, saying, “[P11] I couldn’t get insights from the mind map because I didn’t know how to read the mind map (the connections between concepts).” This highlights the importance of intuitive design that facilitates quick comprehension and efficient navigation. However, training and continued use can mitigate these challenges: “[P13] It was more difficult at first, and then I found the value of it; it became easier for me.” Additionally, some participants (P23, P25-26) claimed that the flexibility in mind map editing and customization in concepts emerged as another critical factor for usability. The ability to modify and tailor mind maps not only enhances their relevance but also keeps designers actively engaged with the content and foster closer alignment with design goals.</p><h2 class="text-2xl font-bold mb-4 mt-8">4 Conclusion and Future Work</h2><p class="mb-4 text-justify">This LBW provides early insights into the use of LLM-generated mind maps in supporting information mapping in VBD. Through a controlled experimental study with 28 designers, we evaluated the performance of LLM-generated mind maps compared to human-generated ones across self-rated scores, effectiveness and user acceptance. LLM-generated mind maps demonstrated advantages in effective collecting data captured from videos in VBD, consistent with previous studies that highlight the effectiveness of LLMs in processing complex information [10,28]. However, compared to the human-generated baseline, LLM-generated mind maps were often criticized for their lack of coherent hierarchies and contextual understanding, and usually required additional manual refinement. Factors such as trust, transparency, and the ability to customize were also identified as critical to the acceptance of LLM-generated mind maps in VBD tasks.</p><p class="mb-4 text-justify">To enhance the utility of LLM-generated mind maps in VBD’s information mapping workflows, we will focus on improving structural and contextual alignment with design processes. We will start from refining prompt templates [33] or developing better technical solutions for distilling LLM prompts [12] to enhance the hierarchical organization of design concepts and foster further customization and usability. Additionally, in our future studies, transparency should also be prioritized to build trust and improve usability. Implementing mechanisms such as detailed model reporting, clear explanations of LLMs’ limitations, and visual feedback on reliability can help users better understand the capabilities and constraints of AI-generated outputs [13]. Finally, as highlighted in previous research [7], presenting LLMs’ uncertainty using less precise but interpretable language could further enhance both the usability and trustworthiness of LLM-generated contents in future information processing tasks.</p><p class="mb-4 text-justify">Output a JSON as plain text to describe the scenario. The JSON should contains nodes whose “label” are related keywords from the topic and edges with “label” as relationships. Include unique ID, position, size, shape for nodes; source, target for edges; and styles for both, with edge length reflecting semantic relevance. Do not put the same IDs for edges. Depend on the contents, generate more than 20 but not less than 30 nodes and edges, and generate 1 to 3 levels of branches as subtopics. Use different node and edge colors and edge lengths to represent relationships. Avoid overlapping. Focus on objective interactions. This is an example: “ “nodes”: [ “id”: “Node1”, “x”: 50, “y”: 50, “size”: [60, 60], “shape”: “circle”, “label”: “Apple”,“id”: “Node2”, “x”: 200, “y”: 50, “size”: [60, 60], “shape”: “circle”, “label”: “iOS”, “id”: “Node3”, “x”: 350, “y”: 50, “size”: [60, 60], “shape”: “circle”, “label”: “App Store”,...]”. Use the example as a template for generation but follow the rules above. This is the scenario: “...”. Here is the transcript: “...”.</p><p class="mb-4 text-justify">Supplementary Text 1: Instructional text displayed.</p>
`,
};


            // Sample quiz questions (will be loaded from external source)
            const quizQuestions = [
                {
                    id: 1,
                    question: "What was the primary methodology used in this study?",
                    options: ["Qualitative analysis", "Quantitative experiments", "Mixed methods", "Literature review"],
                    section: "Methods"
                },
                {
                    id: 2,
                    question: "What was the main finding of the research?",
                    options: ["Option A", "Option B", "Option C", "Option D"],
                    section: "Results"
                },
                // More questions will be added here
            ];

            // Section boundaries
            const sectionBoundaries = {
                'Abstract': { start: 0, end: 200 },
                'Introduction': { start: 200, end: 800 },
                'Related Work': { start: 800, end: 1400 },
                'Methods': { start: 1400, end: 2200 },
                'Results': { start: 2200, end: 3000 },
                'Discussion': { start: 3000, end: 3600 },
                'Conclusion': { start: 3600, end: 4000 },
            };

            // Log event
            const logEvent = (eventType, additionalData = {}) => {
                const now = Date.now();
                const timeSinceLast = now - lastEventTime.current;
                
                const event = {
                    timestamp: now,
                    eventType,
                    phase,
                    timeSinceLast,
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    ...additionalData
                };

                setEvents(prev => [...prev, event]);
                lastEventTime.current = now;

                const storedEvents = JSON.parse(localStorage.getItem('experimentEvents') || '[]');
                storedEvents.push(event);
                localStorage.setItem('experimentEvents', JSON.stringify(storedEvents));
            };

            // Get current section
            const getCurrentSection = (scrollY) => {
                for (const [section, bounds] of Object.entries(sectionBoundaries)) {
                    if (scrollY >= bounds.start && scrollY < bounds.end) {
                        return section;
                    }
                }
                return 'Unknown';
            };

            // Handle scroll - track both pause time AND scroll time
            const handleScroll = (e) => {
                const scrollY = e.target.scrollTop;
                setScrollPosition(scrollY);
                
                const newSection = getCurrentSection(scrollY);
                if (newSection !== currentSection) {
                    setCurrentSection(newSection);
                }

                const now = Date.now();

                // If this is the first scroll (starting to scroll)
                if (!isScrollingRef.current) {
                    isScrollingRef.current = true;
                    scrollStartTimeRef.current = now;
                }

                // Clear existing timeout
                if (scrollTimeoutRef.current) {
                    clearTimeout(scrollTimeoutRef.current);
                }

                // Set new timeout - log event when user stops scrolling for 200ms
                scrollTimeoutRef.current = setTimeout(() => {
                    const scrollStopTime = Date.now();
                    
                    // Calculate times correctly
                    const totalTimeSinceLastStop = scrollStopTime - lastScrollTimeRef.current; // Total time since last event
                    const scrollDuration = scrollStopTime - scrollStartTimeRef.current; // Time spent scrolling
                    const pauseDuration = totalTimeSinceLastStop - scrollDuration; // Time paused (not scrolling)
                    
                    // Classify based on PAUSE duration (time not scrolling)
                    let classification;
                    if (pauseDuration > 5000) {
                        classification = 'reading';
                    } else if (pauseDuration > 2000) {
                        classification = 'scanning';
                    } else {
                        classification = 'scrolling';
                    }

                    logEvent('scroll_pause', { 
                        scrollY, 
                        currentSection: newSection,
                        pauseDuration: pauseDuration,      // Time paused (reading/scanning)
                        scrollDuration: scrollDuration,    // Time spent scrolling
                        classification 
                    });

                    // Update references
                    lastScrollTimeRef.current = scrollStopTime;
                    isScrollingRef.current = false;
                }, 200); // Wait 200ms after scroll stops
            };

            // Handle text selection
            const handleTextSelection = () => {
                const selection = window.getSelection();
                const text = selection.toString();
                if (text.length > 0) {
                    setSelectedText(text);
                    logEvent('text_selection', { selectedText: text });
                }
            };

            // Send LLM message
            const handleSendMessage = async (e) => {
                e.preventDefault();
                if (!inputMessage.trim()) return;

                const userMessage = {
                    role: 'user',
                    content: inputMessage,
                    timestamp: Date.now()
                };

                setMessages(prev => [...prev, userMessage]);
                logEvent('llm_query', { query: inputMessage });
                
                setIsLoading(true);
                const queryText = inputMessage;
                setInputMessage('');

                try {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    const simulatedResponse = `This is a simulated AI response to: "${queryText}". In production, this would be a real ChatGPT API call.`;

                    const assistantMessage = {
                        role: 'assistant',
                        content: simulatedResponse,
                        timestamp: Date.now()
                    };

                    setMessages(prev => [...prev, assistantMessage]);
                    logEvent('llm_response', { query: queryText, response: simulatedResponse });
                } catch (error) {
                    console.error('Error:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            // Start experiment
            const startExperiment = () => {
                if (!participantId || !currentPaper) {
                    alert('Please fill in all fields');
                    return;
                }
                setPhase('reading');
                setReadingActive(true);
                lastScrollTimeRef.current = Date.now(); // Initialize scroll timer
                logEvent('experiment_start');
                logEvent('reading_phase_start');
            };

            // Complete reading phase
            const completeReading = () => {
                setReadingActive(false);
                const readingDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.reading = readingDuration;
                logEvent('reading_phase_complete', { duration: readingDuration });
                setPhase('quiz');
                setQuizActive(true);
                phaseStartTime.current = Date.now(); // Reset for quiz phase
                logEvent('quiz_phase_start');
            };

            // Handle quiz answer
            const handleQuizAnswer = (questionId, answer) => {
                setQuizAnswers(prev => ({ ...prev, [questionId]: answer }));
                logEvent('quiz_answer', { questionId, answer });
            };

            // Complete quiz phase
            const completeQuiz = () => {
                setQuizActive(false);
                const quizDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.quiz = quizDuration;
                logEvent('quiz_phase_complete', { answers: quizAnswers, duration: quizDuration });
                setPhase('review');
                setReviewActive(true);
                phaseStartTime.current = Date.now(); // Reset for review phase
                logEvent('review_phase_start');
            };

            // Handle review change
            const handleReviewChange = (field, value) => {
                setReviewData(prev => ({ ...prev, [field]: value }));
                logEvent('review_edit', { field, valueLength: value.length });
            };

            // Complete review phase
            const completeReview = () => {
                setReviewActive(false);
                const reviewDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.review = reviewDuration;
                logEvent('review_phase_complete', { reviewData, duration: reviewDuration });
                setPhase('complete');
                logEvent('experiment_complete');
            };

            // Export data
            const exportData = () => {
                const experimentData = {
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    phases: {
                        reading: { 
                            completed: true,
                            duration: phaseTimers.current.reading
                        },
                        quiz: { 
                            completed: phase !== 'reading', 
                            answers: quizAnswers,
                            duration: phaseTimers.current.quiz
                        },
                        review: { 
                            completed: phase === 'complete', 
                            data: reviewData,
                            duration: phaseTimers.current.review
                        }
                    },
                    events,
                    messages: condition === 'with_llm' ? messages : []
                };

                const dataStr = JSON.stringify(experimentData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `experiment_${participantId}_${sessionId}.json`;
                link.click();
                
                alert('Data exported successfully!');
            };

            // SETUP PHASE
            if (phase === 'setup') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">PDF Reading Experiment</h1>
                                <p className="text-gray-600">LLM-Assisted Academic Paper Reading Study</p>
                            </div>
                            
                            <div className="space-y-5">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Participant ID *
                                    </label>
                                    <input
                                        type="text"
                                        value={participantId}
                                        onChange={(e) => setParticipantId(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                        placeholder="e.g., P001"
                                    />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Condition *
                                    </label>
                                    <select
                                        value={condition}
                                        onChange={(e) => setCondition(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="without_llm">Without LLM (Control)</option>
                                        <option value="with_llm">With LLM (Experimental)</option>
                                    </select>
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Select Paper *
                                    </label>
                                    <select
                                        value={currentPaper}
                                        onChange={(e) => setCurrentPaper(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="">Choose a paper...</option>
                                        {papers.map(paper => (
                                            <option key={paper.id} value={paper.id}>
                                                {paper.name}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <button
                                    onClick={startExperiment}
                                    disabled={!participantId || !currentPaper}
                                    className="w-full bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-medium transition-colors text-lg mt-6"
                                >
                                    Start Experiment
                                </button>

                                <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                                    <p className="text-sm text-gray-700">
                                        <strong>Experiment Structure:</strong><br/>
                                        1. Reading (30 min)<br/>
                                        2. Quiz (15 min, closed-book)<br/>
                                        3. Review Writing (30 min, open-book)
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // READING PHASE
            if (phase === 'reading') {
                return (
                    <div className="h-screen flex flex-col bg-gray-100">
                        {/* Header with Timer */}
                        <div className="bg-white shadow-md px-6 py-4 flex items-center justify-between border-b-2 border-gray-200">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">
                                    Phase 1: Reading - {papers.find(p => p.id === currentPaper)?.name}
                                </h2>
                                <p className="text-sm text-gray-600">
                                    {participantId} | {condition === 'with_llm' ? 'With LLM' : 'Without LLM'} | Section: <strong>{currentSection}</strong>
                                </p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer 
                                    seconds={30 * 60} 
                                    isActive={readingActive}
                                    phase="reading"
                                    onComplete={() => alert('Reading time is up! Please proceed to the quiz.')}
                                />
                                <button
                                    onClick={completeReading}
                                    className="flex items-center space-x-2 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium"
                                >
                                    <CheckIcon />
                                    <span>Finish Reading</span>
                                </button>
                            </div>
                        </div>

                        {/* Main content */}
                        <div className="flex-1 flex overflow-hidden">
                            {/* PDF Viewer */}
                            <div className={`${condition === 'with_llm' ? 'w-2/3' : 'w-full'} bg-white flex flex-col`}>
                                {/* Toolbar */}
                                <div className="px-6 py-4 border-b bg-gray-50 flex items-center space-x-4">
                                    <div className="flex-1 flex">
                                        <input
                                            type="text"
                                            value={searchTerm}
                                            onChange={(e) => setSearchTerm(e.target.value)}
                                            placeholder="Search in paper..."
                                            className="flex-1 px-4 py-2 border border-gray-300 rounded-l-lg focus:ring-2 focus:ring-blue-500"
                                        />
                                        <button className="px-6 py-2 bg-blue-600 text-white rounded-r-lg hover:bg-blue-700">
                                            <SearchIcon />
                                        </button>
                                    </div>
                                </div>

                                {/* PDF Content */}
                                <div
                                    ref={pdfContainerRef}
                                    onScroll={handleScroll}
                                    onMouseUp={handleTextSelection}
                                    className="flex-1 overflow-y-auto p-8 bg-gray-50"
                                >
                                    <div className="max-w-4xl mx-auto bg-white shadow-xl rounded-lg p-12">
                                        <div 
                                        className="prose max-w-none"
                                        dangerouslySetInnerHTML={{__html: papersContent[currentPaper] || 'Loading...'}}
                                    />
                                </div>
                            </div>

                            {/* Chat Interface (only in with_llm condition) */}
                            {condition === 'with_llm' && (
                                <div className="w-1/3 bg-white border-l-2 border-gray-200 flex flex-col">
                                    <div className="px-6 py-4 border-b bg-gradient-to-r from-blue-600 to-indigo-600 text-white">
                                        <h3 className="font-bold text-lg">AI Research Assistant</h3>
                                        <p className="text-sm text-blue-100">Ask questions about the paper</p>
                                    </div>

                                    <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50">
                                        {messages.length === 0 ? (
                                            <div className="text-center text-gray-500 mt-12">
                                                <div className="text-4xl mb-4">💬</div>
                                                <p className="font-medium">Ask me anything!</p>
                                            </div>
                                        ) : (
                                            messages.map((msg, idx) => (
                                                <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                    <div className={`max-w-[85%] rounded-2xl px-4 py-3 ${
                                                        msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-white text-gray-800 shadow-md'
                                                    }`}>
                                                        <p className="text-sm">{msg.content}</p>
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>

                                    <form onSubmit={handleSendMessage} className="p-4 border-t bg-white">
                                        <div className="flex space-x-2">
                                            <input
                                                type="text"
                                                value={inputMessage}
                                                onChange={(e) => setInputMessage(e.target.value)}
                                                placeholder="Ask a question..."
                                                className="flex-1 px-4 py-3 border border-gray-300 rounded-lg"
                                                disabled={isLoading}
                                            />
                                            <button
                                                type="submit"
                                                disabled={!inputMessage.trim() || isLoading}
                                                className="px-5 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300"
                                            >
                                                <SendIcon />
                                            </button>
                                        </div>
                                    </form>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            // QUIZ PHASE
            if (phase === 'quiz') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Phase 2: Comprehension Quiz</h2>
                                <p className="text-sm text-gray-600">Closed-book | Answer all questions</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer 
                                    seconds={15 * 60} 
                                    isActive={quizActive}
                                    phase="quiz"
                                    onComplete={() => alert('Quiz time is up!')}
                                />
                                <button
                                    onClick={completeQuiz}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Quiz
                                </button>
                            </div>
                        </div>

                        <div className="max-w-4xl mx-auto p-8">
                            <div className="bg-blue-50 border-l-4 border-blue-600 p-4 mb-6">
                                <p className="text-sm">
                                    <strong>Instructions:</strong> Answer the following questions based on your understanding of the paper.
                                    This is a closed-book test - you cannot refer back to the paper.
                                </p>
                            </div>

                            <div className="space-y-6">
                                {quizQuestions.map((q, idx) => (
                                    <div key={q.id} className="bg-white rounded-lg shadow-md p-6">
                                        <div className="flex items-start space-x-3 mb-4">
                                            <span className="flex-shrink-0 w-8 h-8 bg-blue-600 text-white rounded-full flex items-center justify-center font-bold">
                                                {idx + 1}
                                            </span>
                                            <div className="flex-1">
                                                <p className="font-medium text-gray-900 mb-4">{q.question}</p>
                                                <div className="space-y-2">
                                                    {q.options.map((option, optIdx) => (
                                                        <label key={optIdx} className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer">
                                                            <input
                                                                type="radio"
                                                                name={`question-${q.id}`}
                                                                value={option}
                                                                checked={quizAnswers[q.id] === option}
                                                                onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                                className="w-4 h-4"
                                                            />
                                                            <span className="text-gray-700">{option}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-8 p-4 bg-gray-100 rounded-lg">
                                <p className="text-sm text-gray-600">
                                    Progress: {Object.keys(quizAnswers).length} / {quizQuestions.length} questions answered
                                </p>
                            </div>
                        </div>
                    </div>
                );
            }

            // REVIEW PHASE
            if (phase === 'review') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Phase 3: Peer Review Writing</h2>
                                <p className="text-sm text-gray-600">Open-book | Write a comprehensive review</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer 
                                    seconds={30 * 60} 
                                    isActive={reviewActive}
                                    phase="review"
                                    onComplete={() => alert('Review time is up!')}
                                />
                                <button
                                    onClick={completeReview}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Review
                                </button>
                            </div>
                        </div>

                        <div className="max-w-6xl mx-auto p-8">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                {/* Paper (for reference) */}
                                <div className="bg-white rounded-lg shadow-md p-6 max-h-[80vh] overflow-y-auto">
                                    <h3 className="text-xl font-bold mb-4">Paper (Reference)</h3>
                                    <div className="prose">
                                        <h2>Sample Academic Paper</h2>
                                        <p>This is the paper content for reference during review writing...</p>
                                        {/* Same paper content as reading phase */}
                                    </div>
                                </div>

                                {/* Review Form */}
                                <div className="space-y-6">
                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-xl font-bold mb-4">Rating</h3>
                                        <div className="flex items-center space-x-4">
                                            {[1, 2, 3, 4, 5].map(rating => (
                                                <button
                                                    key={rating}
                                                    onClick={() => handleReviewChange('rating', rating)}
                                                    className={`w-12 h-12 rounded-full font-bold transition-colors ${
                                                        reviewData.rating === rating
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                    }`}
                                                >
                                                    {rating}
                                                </button>
                                            ))}
                                        </div>
                                        <p className="text-sm text-gray-600 mt-2">1 = Strong Reject, 5 = Strong Accept</p>
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-3">Strengths</h3>
                                        <textarea
                                            value={reviewData.strengths}
                                            onChange={(e) => handleReviewChange('strengths', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="What are the main strengths of this paper?"
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-3">Weaknesses</h3>
                                        <textarea
                                            value={reviewData.weaknesses}
                                            onChange={(e) => handleReviewChange('weaknesses', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="What are the main weaknesses or limitations?"
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-3">Suggestions for Improvement</h3>
                                        <textarea
                                            value={reviewData.suggestions}
                                            onChange={(e) => handleReviewChange('suggestions', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="How could the authors improve this work?"
                                        />
                                    </div>

                                    <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
                                        <p className="text-sm text-gray-700">
                                            <strong>Tip:</strong> Your review will be evaluated using the AAC&U Critical Thinking VALUE Rubric.
                                            Consider: explanation of issues, use of evidence, context & assumptions, your position, and conclusions.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // COMPLETE PHASE
            if (phase === 'complete') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-12 max-w-2xl w-full text-center">
                            <div className="text-6xl mb-6">🎉</div>
                            <h1 className="text-4xl font-bold text-gray-800 mb-4">Experiment Complete!</h1>
                            <p className="text-xl text-gray-600 mb-8">
                                Thank you for participating in this study.
                            </p>

                            <div className="bg-gray-50 rounded-lg p-6 mb-8 text-left">
                                <h3 className="font-bold text-lg mb-4">Summary</h3>
                                <div className="space-y-2 text-gray-700">
                                    <p>• Participant: <strong>{participantId}</strong></p>
                                    <p>• Condition: <strong>{condition === 'with_llm' ? 'With LLM' : 'Without LLM'}</strong></p>
                                    <p>• Paper: <strong>{papers.find(p => p.id === currentPaper)?.name}</strong></p>
                                    <p>• Quiz Answers: <strong>{Object.keys(quizAnswers).length} / {quizQuestions.length}</strong></p>
                                    <p>• Review Rating: <strong>{reviewData.rating} / 5</strong></p>
                                    <p>• Total Events Logged: <strong>{events.length}</strong></p>
                                </div>
                            </div>

                            <button
                                onClick={exportData}
                                className="px-8 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-lg font-medium"
                            >
                                Download Experiment Data
                            </button>

                            <p className="mt-6 text-sm text-gray-500">
                                Your data has been saved. Please contact the researcher if you have any questions.
                            </p>
                        </div>
                    </div>
                );
            }

            return null;
        }

        ReactDOM.render(<PDFReadingExperiment />, document.getElementById('root'));
    </script>
</body>
</html>