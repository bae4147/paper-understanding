<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Reading Experiment</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, doc, setDoc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyDPd-Fz-PdUwc9uvXAg_xEVR5FyPWCg_zA",
            authDomain: "paper-understanding.firebaseapp.com",
            projectId: "paper-understanding",
            storageBucket: "paper-understanding.firebasestorage.app",
            messagingSenderId: "702665730649",
            appId: "1:702665730649:web:9858bde469085a240fdf48"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Make Firebase available globally
        window.firebaseDb = db;
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseServerTimestamp = serverTimestamp;
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Icons
        const SendIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const SearchIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
        );

        const ClockIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        );

        const CheckIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
        );

        // Timer Component
        function Timer({ seconds, onComplete, isActive, phase }) {
            const [timeLeft, setTimeLeft] = useState(seconds);

            useEffect(() => {
                // Reset timer when phase changes
                setTimeLeft(seconds);
            }, [phase, seconds]);

            useEffect(() => {
                if (!isActive) return;
                
                const interval = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            clearInterval(interval);
                            if (onComplete) onComplete();
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isActive, onComplete]);

            const minutes = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            const isLowTime = timeLeft < 300; // 5Î∂Ñ ÎØ∏Îßå

            return (
                <div className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-mono text-lg ${
                    isLowTime ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700'
                }`}>
                    <ClockIcon />
                    <span>{String(minutes).padStart(2, '0')}:{String(secs).padStart(2, '0')}</span>
                </div>
            );
        }

        // Main Application Component
        function PDFReadingExperiment() {
            // Experiment flow state
            const [phase, setPhase] = useState('setup'); // setup, reading, quiz, review, complete
            const [participantId, setParticipantId] = useState('');
            const [condition, setCondition] = useState('without_llm');
            const [currentPaper, setCurrentPaper] = useState('');
            const [sessionId] = useState(`session_${Date.now()}`);

            // Reading phase state
            const [scrollPosition, setScrollPosition] = useState(0);
            const [currentSection, setCurrentSection] = useState('Introduction');
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedText, setSelectedText] = useState('');
            const [readingActive, setReadingActive] = useState(false);
            const [paperContent, setPaperContent] = useState('');
            
            // Tab state (for with_llm condition)
            const [activeTab, setActiveTab] = useState('reading'); // 'reading' or 'ai'
            const [tabTimes, setTabTimes] = useState({ reading: 0, ai: 0 });
            const tabStartTimeRef = useRef(Date.now());
            const savedScrollPosition = useRef(0); // Ïä§ÌÅ¨Î°§ ÏúÑÏπò Ï†ÄÏû•Ïö©

            // Quiz phase state
            const [quizActive, setQuizActive] = useState(false);
            const [quizAnswers, setQuizAnswers] = useState({});

            // Review phase state
            const [reviewActive, setReviewActive] = useState(false);
            const [reviewData, setReviewData] = useState({
                rating: 3,
                strengths: '',
                weaknesses: '',
                suggestions: ''
            });

            // Chat state (for LLM condition) - enhanced
            const [messages, setMessages] = useState([]);
            const [inputMessage, setInputMessage] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [showPlusMenu, setShowPlusMenu] = useState(false);
            const [chatHistory, setChatHistory] = useState([]); // Full Q&A log
            const [uploadedFiles, setUploadedFiles] = useState([]); // Track uploaded files
            const fileInputRef = useRef(null);

            // Timer tracking
            const phaseStartTime = useRef(Date.now());
            const phaseTimers = useRef({
                reading: 0,
                quiz: 0,
                review: 0
            });

            // Logging state
            const [events, setEvents] = useState([]);
            const lastEventTime = useRef(Date.now());
            const pdfContainerRef = useRef(null);
            const scrollTimeoutRef = useRef(null);
            const lastActivityTimeRef = useRef(Date.now()); // ÎßàÏßÄÎßâ ÌôúÎèô ÏãúÍ∞Ñ (scroll stop ÎòêÎäî tab return)
            const scrollStartTimeRef = useRef(null); // Track when scroll starts
            const isScrollingRef = useRef(false); // Track if currently scrolling
            const sectionBeforeScrollRef = useRef('Introduction'); // Ïä§ÌÅ¨Î°§ ÏãúÏûë Ï†Ñ ÏÑπÏÖò

            // Papers
            const papers = [
                { id: 'chi2025-lbw-01', name: '"A Great Start, But...": Evaluating LLM-Generated Mind Maps for Information Mapping', url: 'papers_html/chi2025-lbw-01.html' },
                // Add more papers here as you process them
            ];

            // Sample quiz questions (will be loaded from external source)
            const quizQuestions = [
                {
                    id: 1,
                    question: "What was the primary methodology used in this study?",
                    options: ["Qualitative analysis", "Quantitative experiments", "Mixed methods", "Literature review"],
                    section: "Methods"
                },
                {
                    id: 2,
                    question: "What was the main finding of the research?",
                    options: ["Option A", "Option B", "Option C", "Option D"],
                    section: "Results"
                },
                // More questions will be added here
            ];

            // Section boundaries
            // Section boundaries - will be loaded dynamically per paper
            const [sectionBoundaries, setSectionBoundaries] = useState({
                'Abstract': { start: 0, end: 200 },
                'Introduction': { start: 200, end: 800 },
                'Methods': { start: 800, end: 1400 },
                'Results': { start: 1400, end: 2200 },
                'Discussion': { start: 2200, end: 2800 },
                'Conclusion': { start: 2800, end: 3200 },
            });

            // Log event
            const logEvent = async (eventType, additionalData = {}) => {
                const now = Date.now();
                const timeSinceLast = now - lastEventTime.current;
                
                const event = {
                    timestamp: now,
                    eventType,
                    phase,
                    timeSinceLast,
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    ...additionalData
                };

                setEvents(prev => [...prev, event]);
                lastEventTime.current = now;

                // Local storage backup
                const storedEvents = JSON.parse(localStorage.getItem('experimentEvents') || '[]');
                storedEvents.push(event);
                localStorage.setItem('experimentEvents', JSON.stringify(storedEvents));

                // Firebase: LLM Í¥ÄÎ†® Ïù¥Î≤§Ìä∏Îßå Ïã§ÏãúÍ∞Ñ Ï†ÄÏû•
                if (eventType === 'llm_question_asked' || eventType === 'llm_answer_received') {
                    try {
                        if (window.firebaseDb && participantId && sessionId) {
                            const experimentRef = window.firebaseDoc(
                                window.firebaseDb,
                                `users/${participantId}/experiments/${sessionId}`
                            );
                            
                            // LLM Î©îÏãúÏßÄÎäî Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ï∂îÍ∞Ä
                            const currentMessages = [...chatHistory];
                            if (eventType === 'llm_answer_received' && additionalData.question) {
                                currentMessages.push({
                                    question: additionalData.question,
                                    answer: additionalData.answer,
                                    responseTime: additionalData.responseTime,
                                    questionTime: now - additionalData.responseTime,
                                    answerTime: now
                                });
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to save LLM event:', error);
                    }
                }
            };

            // Get current section based on viewport center
            const getCurrentSection = (scrollY, viewportHeight) => {
                // Use viewport center as reference point
                const viewportCenter = scrollY + (viewportHeight / 2);
                
                let closestSection = null;
                let closestDistance = Infinity;
                
                // Find which section the viewport center is in
                for (const [section, bounds] of Object.entries(sectionBoundaries)) {
                    // Check if viewport center is within this section
                    if (viewportCenter >= bounds.start && viewportCenter < bounds.end) {
                        return section;
                    }
                    
                    // If no exact match, find closest section (prevents "Unknown")
                    const distanceToStart = Math.abs(viewportCenter - bounds.start);
                    const distanceToEnd = Math.abs(viewportCenter - bounds.end);
                    const minDistance = Math.min(distanceToStart, distanceToEnd);
                    
                    if (minDistance < closestDistance) {
                        closestDistance = minDistance;
                        closestSection = section;
                    }
                }
                
                // Return closest section if no exact match (prevents "Unknown")
                return closestSection || Object.keys(sectionBoundaries)[0] || 'Unknown';
            };

            // Tab switching with time tracking
            const switchTab = (newTab) => {
                if (newTab === activeTab) return;
                
                const now = Date.now();
                
                // LLM ÌÉ≠ÏúºÎ°ú Ï†ÑÌôò: reading ÌÉÄÏù¥Î®∏ Ï§ëÎã® Î∞è ÌòÑÏû¨ Íµ¨Í∞Ñ Ï†ÄÏû•
                if (newTab === 'ai' && activeTab === 'reading') {
                    const pauseDuration = now - lastActivityTimeRef.current;
                    
                    let classification;
                    if (pauseDuration > 5000) {
                        classification = 'reading';
                    } else if (pauseDuration > 2000) {
                        classification = 'scanning';
                    } else {
                        classification = 'scrolling';
                    }
                    
                    logEvent('scroll_action', {
                        scrollY: pdfContainerRef.current?.scrollTop || 0,
                        sectionBeforeScroll: currentSection,
                        sectionAfterScroll: currentSection,
                        classification: classification,
                        pauseDuration: pauseDuration,
                        scrollDuration: 0,
                        isTabSwitch: true,
                        timestamp: now
                    });
                    
                    console.log(`üîÑ [TAB ‚Üí AI] Saved ${classification}: ${pauseDuration}ms at "${currentSection}"`);
                }
                
                // Reading ÌÉ≠ÏúºÎ°ú Î≥µÍ∑Ä: ÌÉÄÏù¥Î®∏ Ïû¨ÏãúÏûë
                if (newTab === 'reading' && activeTab === 'ai') {
                    lastActivityTimeRef.current = now;
                    console.log(`üîÑ [TAB ‚Üí READING] Timer restarted`);
                }
                
                // ÌòÑÏû¨ reading ÌÉ≠Ïù¥Î©¥ Ïä§ÌÅ¨Î°§ ÏúÑÏπò Ï†ÄÏû•
                if (activeTab === 'reading' && pdfContainerRef.current) {
                    savedScrollPosition.current = pdfContainerRef.current.scrollTop;
                    console.log(`üíæ Saved scroll: ${savedScrollPosition.current}px`);
                }
                
                // Record time spent on current tab
                const elapsed = Date.now() - tabStartTimeRef.current;
                setTabTimes(prev => ({
                    ...prev,
                    [activeTab]: prev[activeTab] + elapsed
                }));
                
                // Log tab switch with LLM classification
                const switchEventData = {
                    from: activeTab,
                    to: newTab,
                    timeOnPreviousTab: elapsed
                };
                
                // AI ÌÉ≠ÏóêÏÑú ÎÇòÍ∞ÄÎäî Í≤ΩÏö∞ ‚Üí LLM durationÏúºÎ°ú Î∂ÑÎ•ò
                if (activeTab === 'ai') {
                    switchEventData.classification = 'llm';
                    switchEventData.llmDuration = elapsed;
                    console.log(`ü§ñ [LLM] duration: ${elapsed}ms`);
                }
                
                logEvent('tab_switch', switchEventData);
                
                // Switch to new tab
                setActiveTab(newTab);
                tabStartTimeRef.current = Date.now();
                
                // reading ÌÉ≠ÏúºÎ°ú ÎèåÏïÑÏò§Î©¥ Ïä§ÌÅ¨Î°§ ÏúÑÏπò Î≥µÏõê
                if (newTab === 'reading') {
                    setTimeout(() => {
                        if (pdfContainerRef.current && savedScrollPosition.current > 0) {
                            pdfContainerRef.current.scrollTop = savedScrollPosition.current;
                            console.log(`üìç Restored scroll: ${savedScrollPosition.current}px`);
                        }
                    }, 100);
                }
            };

            // Handle scroll - track reading behavior
            const handleScroll = (e) => {
                // Don't track scroll if not on reading tab
                if (activeTab !== 'reading') return;
                
                const scrollY = e.target.scrollTop;
                const viewportHeight = e.target.clientHeight;
                setScrollPosition(scrollY);
                
                const newSection = getCurrentSection(scrollY, viewportHeight);
                if (newSection !== currentSection) {
                    setCurrentSection(newSection);
                    console.log(`üìç Section changed: ${currentSection} ‚Üí ${newSection} (scroll: ${scrollY}px)`);
                }

                const now = Date.now();

                // Ï≤´ Ïä§ÌÅ¨Î°§ ÏãúÏûë
                if (!isScrollingRef.current) {
                    isScrollingRef.current = true;
                    scrollStartTimeRef.current = now;
                    
                    // Ïä§ÌÅ¨Î°§ ÏãúÏûë Ï†Ñ ÏÑπÏÖò Ï†ÄÏû• (Ïó¨Í∏∞ÏÑú ÏùΩÍ∏∞Í∞Ä Î∞úÏÉùÌï®!)
                    sectionBeforeScrollRef.current = currentSection;
                    
                    // Ï≤´ Ïä§ÌÅ¨Î°§Ïù¥Î©¥ lastActivityTimeRef Ï¥àÍ∏∞Ìôî
                    if (lastActivityTimeRef.current === 0) {
                        lastActivityTimeRef.current = now;
                    }
                }

                // Clear existing timeout
                if (scrollTimeoutRef.current) {
                    clearTimeout(scrollTimeoutRef.current);
                }

                // Ïä§ÌÅ¨Î°§ Î©àÏ∂§ Í∞êÏßÄ (200ms ÎèôÏïà Ïä§ÌÅ¨Î°§ ÏóÜÏúºÎ©¥ Î©àÏ∂ò Í≤ÉÏúºÎ°ú Í∞ÑÏ£º)
                scrollTimeoutRef.current = setTimeout(() => {
                    const scrollStopTime = Date.now();
                    
                    // === ÏãúÍ∞Ñ Í≥ÑÏÇ∞ ===
                    // 1. Ïä§ÌÅ¨Î°§ ÏßÄÏÜç ÏãúÍ∞Ñ: Ïä§ÌÅ¨Î°§ ÏãúÏûë ~ Î©àÏ∂§
                    const scrollDuration = scrollStopTime - scrollStartTimeRef.current;
                    
                    // 2. Ïù¥Ï†Ñ Î©àÏ∂§ ~ Ïù¥Î≤à Ïä§ÌÅ¨Î°§ ÏãúÏûë ÏÇ¨Ïù¥Ïùò ÏãúÍ∞Ñ (= ÏùΩÍ∏∞/Î©àÏ∂∞ÏûàÎçò ÏãúÍ∞Ñ)
                    const pauseBeforeScroll = scrollStartTimeRef.current - lastActivityTimeRef.current;
                    
                    // === ÌñâÎèô Î∂ÑÎ•ò (Ïù¥Ï†Ñ Î©àÏ∂§ ÏãúÍ∞Ñ Í∏∞Ï§Ä) ===
                    let classification;
                    if (pauseBeforeScroll > 5000) {
                        classification = 'reading';  // 5Ï¥à Ïù¥ÏÉÅ Î©àÏ∂§ = ÏùΩÍ∏∞
                    } else if (pauseBeforeScroll > 2000) {
                        classification = 'scanning'; // 2-5Ï¥à Î©àÏ∂§ = ÌõëÏñ¥Î≥¥Í∏∞
                    } else {
                        classification = 'scrolling'; // 2Ï¥à ÎØ∏Îßå = Îπ†Î•∏ Ïä§ÌÅ¨Î°§
                    }

                    // === Ïù¥Î≤§Ìä∏ Î°úÍπÖ ===
                    // Ï§ëÏöî: pauseDuration(ÏùΩÍ∏∞)Ïù¥ Î∞úÏÉùÌïú ÏÑπÏÖòÏùÄ Ïä§ÌÅ¨Î°§ ÏãúÏûë Ï†Ñ ÏÑπÏÖò!
                    const sectionWhereReadingOccurred = sectionBeforeScrollRef.current;
                    const sectionAfterScroll = newSection;
                    
                    logEvent('scroll_action', { 
                        scrollY,
                        sectionBeforeScroll: sectionWhereReadingOccurred,  // ÏùΩÍ∏∞Í∞Ä Î∞úÏÉùÌïú ÏÑπÏÖò
                        sectionAfterScroll: sectionAfterScroll,            // Ïä§ÌÅ¨Î°§ ÌõÑ ÎèÑÏ∞©Ìïú ÏÑπÏÖò
                        classification,                                     // reading/scanning/scrolling
                        pauseDuration: pauseBeforeScroll,                   // Ïù¥Ï†Ñ Î©àÏ∂§ ÏãúÍ∞Ñ (ÏùΩÍ∏∞ ÏãúÍ∞Ñ)
                        scrollDuration: scrollDuration,                     // Ïä§ÌÅ¨Î°§ ÏßÄÏÜç ÏãúÍ∞Ñ
                        timestamp: scrollStopTime
                    });

                    console.log(`üîç [${classification.toUpperCase()}] pause: ${pauseBeforeScroll}ms at "${sectionWhereReadingOccurred}", scroll: ${scrollDuration}ms to "${sectionAfterScroll}"`);

                    // === ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ===
                    lastActivityTimeRef.current = scrollStopTime;
                    isScrollingRef.current = false;
                }, 200);
            };

            // Handle text selection
            const handleTextSelection = () => {
                const selection = window.getSelection();
                const text = selection.toString();
                if (text.length > 0) {
                    setSelectedText(text);
                    logEvent('text_selection', { selectedText: text });
                }
            };

            // Send LLM message
            const handleSendMessage = async (e) => {
                e.preventDefault();
                if (!inputMessage.trim()) return;

                // API ÌÇ§ - GitHub ActionsÏóêÏÑú Ï£ºÏûÖÎê®
                const apiKey = '__OPENAI_API_KEY__'; // ÎπåÎìúÏãú ÍµêÏ≤¥Îê®
                
                const questionTime = Date.now();
                const userMessage = {
                    role: 'user',
                    content: inputMessage,
                    timestamp: questionTime
                };

                setMessages(prev => [...prev, userMessage]);
                logEvent('llm_question_asked', { 
                    question: inputMessage,
                    timestamp: questionTime
                });
                
                setIsLoading(true);
                const queryText = inputMessage;
                setInputMessage('');

                try {
                    // Ïã§Ï†ú OpenAI API Ìò∏Ï∂ú
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4',
                            messages: [
                                ...messages.map(msg => ({
                                    role: msg.role,
                                    content: msg.content
                                })),
                                {
                                    role: 'user',
                                    content: queryText
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 1000
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || 'API request failed');
                    }

                    const data = await response.json();
                    const simulatedResponse = data.choices[0].message.content;
                    const answerTime = Date.now();

                    const assistantMessage = {
                        role: 'assistant',
                        content: simulatedResponse,
                        timestamp: answerTime
                    };

                    setMessages(prev => [...prev, assistantMessage]);
                    
                    // Log to chatHistory
                    const qa = {
                        question: queryText,
                        questionTime: questionTime,
                        answer: simulatedResponse,
                        answerTime: answerTime,
                        responseTime: answerTime - questionTime
                    };
                    setChatHistory(prev => [...prev, qa]);
                    
                    logEvent('llm_answer_received', { 
                        question: queryText,
                        answer: simulatedResponse,
                        responseTime: answerTime - questionTime,
                        timestamp: answerTime
                    });
                } catch (error) {
                    console.error('Error calling OpenAI API:', error);
                    // ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú
                    const errorMessage = {
                        role: 'assistant',
                        content: `Sorry, I encountered an error: ${error.message}. Please check the API key and try again.`,
                        timestamp: Date.now()
                    };
                    setMessages(prev => [...prev, errorMessage]);
                } finally {
                    setIsLoading(false);
                }
            };

            // Handle file upload
            const handleFileUpload = (e) => {
                const files = Array.from(e.target.files);
                const newFiles = files.map(file => ({
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    timestamp: Date.now()
                }));
                
                setUploadedFiles(prev => [...prev, ...newFiles]);
                logEvent('file_uploaded', { files: newFiles.map(f => f.name) });
                setShowPlusMenu(false);
                
                // Show in chat as uploaded
                const uploadMessage = {
                    role: 'system',
                    content: `üìé Uploaded: ${files.map(f => f.name).join(', ')}`,
                    timestamp: Date.now()
                };
                setMessages(prev => [...prev, uploadMessage]);
            };

            // Start experiment
            const startExperiment = async () => {
                if (!participantId || !currentPaper) {
                    alert('Please fill in all fields');
                    return;
                }
                
                // Load paper content and metadata
                const paper = papers.find(p => p.id === currentPaper);
                if (paper && paper.url) {
                    try {
                        // Load HTML content
                        const response = await fetch(paper.url);
                        const html = await response.text();
                        
                        // Parse HTML and extract prose content
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const proseDiv = doc.querySelector('.prose');
                        
                        if (proseDiv) {
                            setPaperContent(proseDiv.innerHTML);
                            
                            // Calculate actual section boundaries from DOM
                            setTimeout(() => {
                                const sections = document.querySelectorAll('[data-section]');
                                const container = document.getElementById('paper-content') || document.querySelector('.prose');
                                
                                if (sections.length > 0 && container) {
                                    const newBoundaries = {};
                                    
                                    sections.forEach((section, index) => {
                                        const sectionName = section.getAttribute('data-section');
                                        const sectionTop = section.offsetTop;
                                        
                                        let sectionEnd;
                                        if (index < sections.length - 1) {
                                            sectionEnd = sections[index + 1].offsetTop;
                                        } else {
                                            sectionEnd = container.scrollHeight;
                                        }
                                        
                                        newBoundaries[sectionName] = {
                                            start: sectionTop,
                                            end: sectionEnd
                                        };
                                    });
                                    
                                    setSectionBoundaries(newBoundaries);
                                    console.log('üìä Section Boundaries loaded:', newBoundaries);
                                    
                                    // Set initial section
                                    const firstSection = Object.keys(newBoundaries)[0];
                                    if (firstSection) {
                                        setCurrentSection(firstSection);
                                    }
                                } else {
                                    console.warn('‚ö†Ô∏è No sections found in paper');
                                }
                            }, 500); // Wait for DOM to render
                            
                        } else {
                            setPaperContent('<p>Error: Could not load paper content</p>');
                        }
                    } catch (error) {
                        console.error('Error loading paper:', error);
                        setPaperContent('<p>Error loading paper. Please check the file path.</p>');
                    }
                }
                
                setPhase('reading');
                setReadingActive(true);
                lastActivityTimeRef.current = Date.now(); // Initialize scroll timer
                
                // Firebase: Ïã§Ìóò Î¨∏ÏÑú ÏÉùÏÑ±
                try {
                    if (window.firebaseDb) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        await window.firebaseSetDoc(experimentRef, {
                            participantId: participantId,
                            sessionId: sessionId,
                            condition: condition,
                            paper: currentPaper,
                            startedAt: window.firebaseServerTimestamp(),
                            status: 'in_progress',
                            createdAt: Date.now()
                        });
                        
                        console.log('‚úÖ Experiment document created:', `users/${participantId}/experiments/${sessionId}`);
                    }
                } catch (error) {
                    console.error('‚ùå Failed to create experiment document:', error);
                }
                
                logEvent('experiment_start');
                logEvent('reading_phase_start');
            };

            // Complete reading phase
            const completeReading = async () => {
                setReadingActive(false);
                
                // ÎßàÏßÄÎßâ ÏùΩÍ∏∞ Íµ¨Í∞Ñ Í∞ïÏ†ú Î°úÍπÖ (Finish Î≤ÑÌäº ÎàÑÎ•¥Í∏∞ ÏßÅÏ†Ñ)
                const now = Date.now();
                const finalPauseDuration = now - lastActivityTimeRef.current;
                
                let finalClassification;
                if (finalPauseDuration > 5000) {
                    finalClassification = 'reading';
                } else if (finalPauseDuration > 2000) {
                    finalClassification = 'scanning';
                } else {
                    finalClassification = 'scrolling';
                }
                
                logEvent('scroll_action', {
                    scrollY: pdfContainerRef.current?.scrollTop || 0,
                    sectionBeforeScroll: currentSection,
                    sectionAfterScroll: currentSection,
                    classification: finalClassification,
                    pauseDuration: finalPauseDuration,
                    scrollDuration: 0,
                    isFinalSegment: true,  // ÎßàÏßÄÎßâ Íµ¨Í∞Ñ ÌëúÏãú
                    timestamp: now
                });
                
                console.log(`üèÅ [FINAL ${finalClassification.toUpperCase()}] pause: ${finalPauseDuration}ms at "${currentSection}"`);
                
                // Record final tab time
                const elapsed = Date.now() - tabStartTimeRef.current;
                const finalTabTimes = {
                    ...tabTimes,
                    [activeTab]: tabTimes[activeTab] + elapsed
                };
                
                const readingDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.reading = readingDuration;
                
                // Classification ÏöîÏïΩ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                const scrollEvents = events.filter(e => e.eventType === 'scroll_action');
                const classificationSummary = {
                    reading: {
                        count: scrollEvents.filter(e => e.classification === 'reading').length,
                        totalDuration: scrollEvents
                            .filter(e => e.classification === 'reading')
                            .reduce((sum, e) => sum + (e.pauseDuration || 0), 0),
                        sections: [...new Set(scrollEvents
                            .filter(e => e.classification === 'reading')
                            .map(e => e.sectionBeforeScroll))]
                    },
                    scanning: {
                        count: scrollEvents.filter(e => e.classification === 'scanning').length,
                        totalDuration: scrollEvents
                            .filter(e => e.classification === 'scanning')
                            .reduce((sum, e) => sum + (e.pauseDuration || 0), 0),
                        sections: [...new Set(scrollEvents
                            .filter(e => e.classification === 'scanning')
                            .map(e => e.sectionBeforeScroll))]
                    },
                    scrolling: {
                        count: scrollEvents.filter(e => e.classification === 'scrolling').length,
                        totalDuration: scrollEvents
                            .filter(e => e.classification === 'scrolling')
                            .reduce((sum, e) => sum + (e.pauseDuration || 0), 0),
                        sections: [...new Set(scrollEvents
                            .filter(e => e.classification === 'scrolling')
                            .map(e => e.sectionBeforeScroll))]
                    }
                };
                
                // ÏÑπÏÖòÎ≥Ñ Î∂ÑÏÑù
                const sectionAnalysis = {};
                scrollEvents.forEach(e => {
                    const section = e.sectionBeforeScroll;
                    if (!sectionAnalysis[section]) {
                        sectionAnalysis[section] = { reading: 0, scanning: 0, scrolling: 0 };
                    }
                    sectionAnalysis[section][e.classification] += (e.pauseDuration || 0);
                });
                
                logEvent('reading_phase_complete', { 
                    duration: readingDuration,
                    tabTimes: finalTabTimes,
                    chatHistory: chatHistory,
                    classificationSummary,
                    sectionAnalysis
                });
                
                // Firebase: Ïã§Ìóò Î¨∏ÏÑúÏóê reading ÏöîÏïΩ + Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥ Ï†ÄÏû•
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        // Reading phaseÏùò Î™®Îì† Ïù¥Î≤§Ìä∏ ÌïÑÌÑ∞ÎßÅ
                        const readingEvents = events.filter(e => 
                            e.phase === 'reading' && 
                            (e.eventType === 'scroll_action' || 
                             e.eventType === 'tab_switch' ||
                             e.eventType === 'text_selection')
                        );
                        
                        const updateData = {
                            'reading.duration': readingDuration,
                            'reading.tabTimes': finalTabTimes,
                            'reading.classificationSummary': classificationSummary,
                            'reading.sectionAnalysis': sectionAnalysis,
                            'reading.events': readingEvents, // Î™®Îì† Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥Î°ú Ï†ÄÏû•
                            'reading.completedAt': window.firebaseServerTimestamp()
                        };
                        
                        // with_llm Ï°∞Í±¥Ïù¥Î©¥ LLM interaction Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
                        if (condition === 'with_llm' && chatHistory.length > 0) {
                            updateData['llmInteraction.messages'] = chatHistory;
                            updateData['llmInteraction.totalQueries'] = chatHistory.length;
                            updateData['llmInteraction.avgResponseTime'] = chatHistory.length > 0
                                ? chatHistory.reduce((sum, qa) => sum + qa.responseTime, 0) / chatHistory.length
                                : 0;
                        }
                        
                        await window.firebaseUpdateDoc(experimentRef, updateData);
                        
                        console.log('‚úÖ Reading phase data saved (with', readingEvents.length, 'events)');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to save reading summary:', error);
                }
                
                setPhase('quiz');
                setQuizActive(true);
                phaseStartTime.current = Date.now(); // Reset for quiz phase
                logEvent('quiz_phase_start');
            };

            // Handle quiz answer
            const handleQuizAnswer = (questionId, answer) => {
                setQuizAnswers(prev => ({ ...prev, [questionId]: answer }));
                logEvent('quiz_answer', { questionId, answer });
            };

            // Complete quiz phase
            const completeQuiz = async () => {
                setQuizActive(false);
                const quizDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.quiz = quizDuration;
                logEvent('quiz_phase_complete', { answers: quizAnswers, duration: quizDuration });
                
                // Firebase: Quiz Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        await window.firebaseUpdateDoc(experimentRef, {
                            'quiz.answers': quizAnswers,
                            'quiz.duration': quizDuration,
                            'quiz.submittedAt': window.firebaseServerTimestamp()
                        });
                        
                        console.log('‚úÖ Quiz data saved');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to save quiz data:', error);
                }
                
                setPhase('review');
                setReviewActive(true);
                phaseStartTime.current = Date.now(); // Reset for review phase
                logEvent('review_phase_start');
            };

            // Handle review change
            const handleReviewChange = (field, value) => {
                setReviewData(prev => ({ ...prev, [field]: value }));
                logEvent('review_edit', { field, valueLength: value.length });
            };

            // Complete review phase
            const completeReview = async () => {
                setReviewActive(false);
                const reviewDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.review = reviewDuration;
                logEvent('review_phase_complete', { reviewData, duration: reviewDuration });
                
                // Firebase: Review Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Î∞è Ïã§Ìóò ÏôÑÎ£å Ï≤òÎ¶¨
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );
                        
                        await window.firebaseUpdateDoc(experimentRef, {
                            'review.rating': reviewData.rating,
                            'review.strengths': reviewData.strengths,
                            'review.weaknesses': reviewData.weaknesses,
                            'review.suggestions': reviewData.suggestions,
                            'review.duration': reviewDuration,
                            'review.submittedAt': window.firebaseServerTimestamp(),
                            'status': 'completed',
                            'completedAt': window.firebaseServerTimestamp()
                        });
                        
                        console.log('‚úÖ Experiment completed and saved');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to complete experiment:', error);
                }
                
                setPhase('complete');
                logEvent('experiment_complete');
            };

            // Export data
            const exportData = async () => {
                const experimentData = {
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    phases: {
                        reading: { 
                            completed: true,
                            duration: phaseTimers.current.reading
                        },
                        quiz: { 
                            completed: phase !== 'reading', 
                            answers: quizAnswers,
                            duration: phaseTimers.current.quiz
                        },
                        review: { 
                            completed: phase === 'complete', 
                            data: reviewData,
                            duration: phaseTimers.current.review
                        }
                    },
                    events,
                    messages: condition === 'with_llm' ? messages : [],
                    completedAt: new Date().toISOString()
                };

                // FirebaseÏóê Ï†ÑÏ≤¥ Ïã§Ìóò Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                try {
                    if (window.firebaseDb) {
                        await window.firebaseAddDoc(
                            window.firebaseCollection(window.firebaseDb, 'experiments'),
                            {
                                ...experimentData,
                                serverTimestamp: window.firebaseServerTimestamp()
                            }
                        );
                        console.log('FirebaseÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å');
                    }
                } catch (error) {
                    console.error('Firebase Ï†ÄÏû• Ïã§Ìå®:', error);
                }

                // Î°úÏª¨ JSON Îã§Ïö¥Î°úÎìú (Î∞±ÏóÖÏö©)
                const dataStr = JSON.stringify(experimentData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `experiment_${participantId}_${sessionId}.json`;
                link.click();
                
                alert('Data saved to Firebase and downloaded as backup!');
            };

            // SETUP PHASE
            if (phase === 'setup') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">PDF Reading Experiment</h1>
                                <p className="text-gray-600">LLM-Assisted Academic Paper Reading Study</p>
                            </div>
                            
                            <div className="space-y-5">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Participant ID *
                                    </label>
                                    <input
                                        type="text"
                                        value={participantId}
                                        onChange={(e) => setParticipantId(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                        placeholder="e.g., P001"
                                    />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Condition *
                                    </label>
                                    <select
                                        value={condition}
                                        onChange={(e) => setCondition(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="without_llm">Without LLM (Control)</option>
                                        <option value="with_llm">With LLM (Experimental)</option>
                                    </select>
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Select Paper *
                                    </label>
                                    <select
                                        value={currentPaper}
                                        onChange={(e) => setCurrentPaper(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="">Choose a paper...</option>
                                        {papers.map(paper => (
                                            <option key={paper.id} value={paper.id}>
                                                {paper.name}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <button
                                    onClick={startExperiment}
                                    disabled={!participantId || !currentPaper}
                                    className="w-full bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-medium transition-colors text-lg mt-6"
                                >
                                    Start Experiment
                                </button>

                                <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                                    <p className="text-sm text-gray-700">
                                        <strong>Experiment Structure:</strong><br/>
                                        1. Reading (30 min)<br/>
                                        2. Quiz (15 min, closed-book)<br/>
                                        3. Review Writing (30 min, open-book)
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // READING PHASE
            if (phase === 'reading') {
                return (
                    <div className="h-screen flex flex-col bg-gray-100">
                        {/* Header with Timer */}
                        <div className="bg-white shadow-md px-6 py-4 flex items-center justify-between border-b-2 border-gray-200">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">
                                    Phase 1: Reading - {papers.find(p => p.id === currentPaper)?.name}
                                </h2>
                                <p className="text-sm text-gray-600">
                                    {participantId} | {condition === 'with_llm' ? 'With LLM' : 'Without LLM'} | Section: <strong>{currentSection}</strong>
                                </p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer 
                                    seconds={30 * 60} 
                                    isActive={readingActive}
                                    phase="reading"
                                    onComplete={() => alert('Reading time is up! Please proceed to the quiz.')}
                                />
                                <button
                                    onClick={completeReading}
                                    className="flex items-center space-x-2 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium"
                                >
                                    <CheckIcon />
                                    <span>Finish Reading</span>
                                </button>
                            </div>
                        </div>

                        {/* Main content */}
                        <div className="flex-1 flex flex-col overflow-hidden">
                            {/* Tabs (only for with_llm condition) */}
                            {condition === 'with_llm' && (
                                <div className="bg-white border-b-2 border-gray-200">
                                    <div className="flex space-x-1 px-4">
                                        <button
                                            onClick={() => switchTab('reading')}
                                            className={`px-6 py-3 font-medium transition-colors ${
                                                activeTab === 'reading'
                                                    ? 'border-b-2 border-blue-600 text-blue-600'
                                                    : 'text-gray-600 hover:text-gray-800'
                                            }`}
                                        >
                                            üìÑ Reading
                                        </button>
                                        <button
                                            onClick={() => switchTab('ai')}
                                            className={`px-6 py-3 font-medium transition-colors ${
                                                activeTab === 'ai'
                                                    ? 'border-b-2 border-blue-600 text-blue-600'
                                                    : 'text-gray-600 hover:text-gray-800'
                                            }`}
                                        >
                                            ü§ñ AI Assistant
                                        </button>
                                    </div>
                                </div>
                            )}

                            {/* Reading Tab Content */}
                            {(condition === 'without_llm' || activeTab === 'reading') && (
                                <div className="flex-1 bg-white flex flex-col overflow-hidden">
                                {/* Toolbar */}
                                <div className="px-6 py-4 border-b bg-gray-50 flex items-center space-x-4 flex-shrink-0">
                                    <div className="flex-1 flex">
                                        <input
                                            type="text"
                                            value={searchTerm}
                                            onChange={(e) => setSearchTerm(e.target.value)}
                                            placeholder="Search in paper..."
                                            className="flex-1 px-4 py-2 border border-gray-300 rounded-l-lg focus:ring-2 focus:ring-blue-500"
                                        />
                                        <button className="px-6 py-2 bg-blue-600 text-white rounded-r-lg hover:bg-blue-700">
                                            <SearchIcon />
                                        </button>
                                    </div>
                                </div>

                                {/* PDF Content */}
                                <div
                                    ref={pdfContainerRef}
                                    onScroll={handleScroll}
                                    onMouseUp={handleTextSelection}
                                    className="flex-1 overflow-y-auto p-8 bg-gray-50"
                                >
                                    <div className="max-w-4xl mx-auto bg-white shadow-xl rounded-lg p-12">
                                        <div 
                                            id="paper-content"
                                            className="prose max-w-none"
                                            dangerouslySetInnerHTML={{ __html: paperContent || '<p>Loading paper...</p>' }}
                                        />
                                    </div>
                                </div>
                            </div>

                            )}

                            {/* AI Assistant Tab Content */}
                            {condition === 'with_llm' && activeTab === 'ai' && (
                                <div className="flex-1 bg-white flex flex-col overflow-hidden">
                                    {/* ChatGPT-style header */}
                                    <div className="px-4 py-3 border-b bg-white flex items-center justify-between">
                                        <div className="flex items-center space-x-2">
                                            <span className="text-xl font-semibold">ChatGPT</span>
                                            <span className="text-sm text-gray-500">5</span>
                                        </div>
                                    </div>

                                    <div className="flex-1 overflow-y-auto bg-white">
                                        {messages.length === 0 ? (
                                            <div className="text-center text-gray-500 mt-12">
                                                <div className="text-4xl mb-4">üí¨</div>
                                                <p className="font-medium">Ask me anything!</p>
                                            </div>
                                        ) : (
                                            messages.map((msg, idx) => (
                                                <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                    <div className={`max-w-[85%] rounded-2xl px-4 py-3 ${
                                                        msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-white text-gray-800 shadow-md'
                                                    }`}>
                                                        <p className="text-sm">{msg.content}</p>
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>

                                    {/* ChatGPT-style Input Area */}
                                    <div className="p-6 border-t bg-white">
                                        <div className="max-w-3xl mx-auto">
                                            <form onSubmit={handleSendMessage} className="relative">
                                                {/* Hidden file input */}
                                                <input
                                                    ref={fileInputRef}
                                                    type="file"
                                                    multiple
                                                    onChange={handleFileUpload}
                                                    className="hidden"
                                                    accept="image/*,.pdf,.doc,.docx,.txt"
                                                />
                                                
                                                <div className="flex items-center border border-gray-300 rounded-3xl bg-gray-50 shadow-sm hover:shadow-md transition-shadow focus-within:border-gray-400">
                                                    {/* Plus Button with Menu */}
                                                    <div className="relative">
                                                        <button
                                                            type="button"
                                                            onClick={() => setShowPlusMenu(!showPlusMenu)}
                                                            className="p-3 hover:bg-gray-200 rounded-full transition-colors ml-2"
                                                        >
                                                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                                            </svg>
                                                        </button>
                                                        
                                                        {/* Plus Menu Popup */}
                                                        {showPlusMenu && (
                                                            <div className="absolute bottom-full left-0 mb-2 w-64 bg-white rounded-lg shadow-2xl border border-gray-200 py-2 z-50">
                                                                <button
                                                                    type="button"
                                                                    onClick={() => fileInputRef.current?.click()}
                                                                    className="w-full px-4 py-3 text-left hover:bg-gray-50 flex items-center space-x-3 transition-colors"
                                                                >
                                                                    <svg className="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
                                                                    </svg>
                                                                    <span className="font-medium text-gray-800">Add photos & files</span>
                                                                </button>
                                                                <button
                                                                    type="button"
                                                                    onClick={() => {
                                                                        alert('Web search - Coming soon!');
                                                                        setShowPlusMenu(false);
                                                                    }}
                                                                    className="w-full px-4 py-3 text-left hover:bg-gray-50 flex items-center space-x-3 transition-colors"
                                                                >
                                                                    <svg className="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                                                    </svg>
                                                                    <span className="font-medium text-gray-800">Web search</span>
                                                                </button>
                                                            </div>
                                                        )}
                                                    </div>
                                                    
                                                    {/* Input Field */}
                                                    <input
                                                        type="text"
                                                        value={inputMessage}
                                                        onChange={(e) => setInputMessage(e.target.value)}
                                                        placeholder="Message ChatGPT"
                                                        className="flex-1 px-4 py-3 bg-transparent focus:outline-none text-gray-900 placeholder-gray-500"
                                                        disabled={isLoading}
                                                    />
                                                    
                                                    {/* Send Button */}
                                                    <button
                                                        type="submit"
                                                        disabled={isLoading || !inputMessage.trim()}
                                                        className="p-2 mr-2 rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                                                    >
                                                        <div className={`w-8 h-8 rounded-full flex items-center justify-center transition-colors ${
                                                            inputMessage.trim() ? 'bg-black text-white' : 'bg-gray-300 text-gray-500'
                                                        }`}>
                                                            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                                                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                                            </svg>
                                                        </div>
                                                    </button>
                                                </div>
                                            </form>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            // QUIZ PHASE
            if (phase === 'quiz') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Phase 2: Comprehension Quiz</h2>
                                <p className="text-sm text-gray-600">Closed-book | Answer all questions</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer 
                                    seconds={15 * 60} 
                                    isActive={quizActive}
                                    phase="quiz"
                                    onComplete={() => alert('Quiz time is up!')}
                                />
                                <button
                                    onClick={completeQuiz}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Quiz
                                </button>
                            </div>
                        </div>

                        <div className="max-w-4xl mx-auto p-8">
                            <div className="bg-blue-50 border-l-4 border-blue-600 p-4 mb-6">
                                <p className="text-sm">
                                    <strong>Instructions:</strong> Answer the following questions based on your understanding of the paper.
                                    This is a closed-book test - you cannot refer back to the paper.
                                </p>
                            </div>

                            <div className="space-y-6">
                                {quizQuestions.map((q, idx) => (
                                    <div key={q.id} className="bg-white rounded-lg shadow-md p-6">
                                        <div className="flex items-start space-x-3 mb-4">
                                            <span className="flex-shrink-0 w-8 h-8 bg-blue-600 text-white rounded-full flex items-center justify-center font-bold">
                                                {idx + 1}
                                            </span>
                                            <div className="flex-1">
                                                <p className="font-medium text-gray-900 mb-4">{q.question}</p>
                                                <div className="space-y-2">
                                                    {q.options.map((option, optIdx) => (
                                                        <label key={optIdx} className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer">
                                                            <input
                                                                type="radio"
                                                                name={`question-${q.id}`}
                                                                value={option}
                                                                checked={quizAnswers[q.id] === option}
                                                                onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                                className="w-4 h-4"
                                                            />
                                                            <span className="text-gray-700">{option}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-8 p-4 bg-gray-100 rounded-lg">
                                <p className="text-sm text-gray-600">
                                    Progress: {Object.keys(quizAnswers).length} / {quizQuestions.length} questions answered
                                </p>
                            </div>
                        </div>
                    </div>
                );
            }

            // REVIEW PHASE
            if (phase === 'review') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Phase 3: Peer Review Writing</h2>
                                <p className="text-sm text-gray-600">Open-book | Write a comprehensive review</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer 
                                    seconds={30 * 60} 
                                    isActive={reviewActive}
                                    phase="review"
                                    onComplete={() => alert('Review time is up!')}
                                />
                                <button
                                    onClick={completeReview}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Review
                                </button>
                            </div>
                        </div>

                        <div className="max-w-6xl mx-auto p-8">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                {/* Paper (for reference) */}
                                <div className="bg-white rounded-lg shadow-md p-6 max-h-[80vh] overflow-y-auto">
                                    <h3 className="text-xl font-bold mb-4">Paper (Reference)</h3>
                                    <div className="prose">
                                        <h2>Sample Academic Paper</h2>
                                        <p>This is the paper content for reference during review writing...</p>
                                        {/* Same paper content as reading phase */}
                                    </div>
                                </div>

                                {/* Review Form */}
                                <div className="space-y-6">
                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-xl font-bold mb-4">Rating</h3>
                                        <div className="flex items-center space-x-4">
                                            {[1, 2, 3, 4, 5].map(rating => (
                                                <button
                                                    key={rating}
                                                    onClick={() => handleReviewChange('rating', rating)}
                                                    className={`w-12 h-12 rounded-full font-bold transition-colors ${
                                                        reviewData.rating === rating
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                    }`}
                                                >
                                                    {rating}
                                                </button>
                                            ))}
                                        </div>
                                        <p className="text-sm text-gray-600 mt-2">1 = Strong Reject, 5 = Strong Accept</p>
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-3">Strengths</h3>
                                        <textarea
                                            value={reviewData.strengths}
                                            onChange={(e) => handleReviewChange('strengths', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="What are the main strengths of this paper?"
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-3">Weaknesses</h3>
                                        <textarea
                                            value={reviewData.weaknesses}
                                            onChange={(e) => handleReviewChange('weaknesses', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="What are the main weaknesses or limitations?"
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-3">Suggestions for Improvement</h3>
                                        <textarea
                                            value={reviewData.suggestions}
                                            onChange={(e) => handleReviewChange('suggestions', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="How could the authors improve this work?"
                                        />
                                    </div>

                                    <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
                                        <p className="text-sm text-gray-700">
                                            <strong>Tip:</strong> Your review will be evaluated using the AAC&U Critical Thinking VALUE Rubric.
                                            Consider: explanation of issues, use of evidence, context & assumptions, your position, and conclusions.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // COMPLETE PHASE
            if (phase === 'complete') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-12 max-w-2xl w-full text-center">
                            <div className="text-6xl mb-6">üéâ</div>
                            <h1 className="text-4xl font-bold text-gray-800 mb-4">Experiment Complete!</h1>
                            <p className="text-xl text-gray-600 mb-8">
                                Thank you for participating in this study.
                            </p>

                            <div className="bg-gray-50 rounded-lg p-6 mb-8 text-left">
                                <h3 className="font-bold text-lg mb-4">Summary</h3>
                                <div className="space-y-2 text-gray-700">
                                    <p>‚Ä¢ Participant: <strong>{participantId}</strong></p>
                                    <p>‚Ä¢ Condition: <strong>{condition === 'with_llm' ? 'With LLM' : 'Without LLM'}</strong></p>
                                    <p>‚Ä¢ Paper: <strong>{papers.find(p => p.id === currentPaper)?.name}</strong></p>
                                    <p>‚Ä¢ Quiz Answers: <strong>{Object.keys(quizAnswers).length} / {quizQuestions.length}</strong></p>
                                    <p>‚Ä¢ Review Rating: <strong>{reviewData.rating} / 5</strong></p>
                                    <p>‚Ä¢ Total Events Logged: <strong>{events.length}</strong></p>
                                </div>
                            </div>

                            <button
                                onClick={exportData}
                                className="px-8 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-lg font-medium"
                            >
                                Download Experiment Data
                            </button>

                            <p className="mt-6 text-sm text-gray-500">
                                Your data has been saved. Please contact the researcher if you have any questions.
                            </p>
                        </div>
                    </div>
                );
            }

            return null;
        }

        ReactDOM.render(<PDFReadingExperiment />, document.getElementById('root'));
    </script>
</body>
</html>